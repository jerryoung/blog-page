<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hystrix 是如何工作？（翻译）]]></title>
    <url>%2F2020%2F03%2F08%2FHystrix-How-it-Works%2F</url>
    <content type="text"><![CDATA[原文链接 Hystrix-流程图下图显示了通过Hystrix向服务依赖项请求时发生的情况： 以下各节将更详细地说明此流程： 1.构造一个HystrixCommand或HystrixObservableCommand对象 2.执行Command 3.响应是否缓存 4.电路是否已经开路 5.线程池/队列/信号量是否已经满 6.HystrixObservableCommand.construct()或者HystrixCommand.run()或者HystrixCommand.run()) 7.计算电路健康 8.获取后备 9.返回成功的响应 1.构造一个HystrixCommand或HystrixObservableCommand对象第一步，是构造一个HystrixCommand或HystrixObservableCommand对象，以表示您对依赖项的请求。向构造函数传递发出请求时所需的任何参数。 如果期待依赖返回单个响应，则构造一个 HystrixCommand对象，例如 1HystrixCommand command = new HystrixCommand(arg1, arg2); 如果期待依赖项返回一个可发出响应的Observable，则构造一个 HystrixObservableCommand 对象，例如 1HystrixObservableCommand command = new HystrixObservableCommand(arg1, arg2); 2.执行Command使用Hystrix命令对象的以下四种方法之一，可以执行命令的方式有四种（前两种仅适用于简单的HystrixCommand对象，而不适用于HystrixObservableCommand）： execute()) — 代码块，然后返回从依赖项收到单个响应（发生错误的情况下引发的异常） queue()) — 返回一个 Future ，您可以使用它从依赖项获得单个响应 observe()) — 订阅表示来自 依赖项的Observable 的响应，并返回复制源 Observable 的 Observable toObservable()) — 返回一个 Observable ,当您订阅它的时候，它将会执行Hystrix命令并发出其响应 1234K value = command.execute();Future&lt;K&gt; fValue = command.queue();Observable&lt;K&gt; ohValue = command.observe(); //hot observableObservable&lt;K&gt; ocValue = command.toObservable(); //cold observable 同步调用 execute() ，调用 queue().get(). queue() 依次调用toObservable().toBlocking().toFuture(). 就是说，最终每个 HystrixCommand 都由一个 Observable 实现, 即使那些只是想返回单个简单的命令也是如此 3.响应是否缓存如果为此命令启用了请求缓存，并且如果对请求的响应在缓存中可用，则该缓存的响应将立即以Observable 的形式返回。 (See “Request Caching” below.) 4.电路是否已经开路 维基百科：开路 电路三种状态： 当你执行这个命令，Hystrix 会检查断路器，以查看断路器是否是open。 如果电路是open（或跳闸），然后Hystrix将不会执行这个命令，但将会路由路由到8. Get the Fallback。 如果电路是闭合的，则流程到5. Semaphore/Thread pool rejected.，以检查是否有可用于运行该命令的容量。 5.线程池/队列/信号量是否已经满如果与该命令关联的线程池和队列（或信号量，如果没有运行在线程上）已满，则Hystrix将不会执行该命令，但会马上返回8. Get the Fallback 6.HystrixObservableCommand.construct()或者HystrixCommand.run()在这里， Hystrix 通过为此目的编写方法（以下之一）调用对依赖项的请求: HystrixCommand.run()) — 返回单个响应或抛出异常 HystrixObservableCommand.construct()) — 返回一个Observable ，它发出响应或发送onError 通知 If the run() or construct() method exceeds the command’s timeout value, the thread will throw a TimeoutException (or a separate timer thread will, if the command itself is not running in its own thread). In that case Hystrix routes the response through 8. Get the Fallback, and it discards the eventual return value run() or construct() method if that method does not cancel/interrupt. 如果run（）或construct（）方法的值超过了命令的超时的数值，则线程将抛出“ TimeoutException”（或者，如果命令本身未在其自己的线程中运行，则线程将抛出单独的计时器线程）。在那种情况下，Hystrix将响应路由到8. Get the Fallback，如果该方法没有取消/中断，则它会丢弃最终的返回值run() 或者construct() 方法。 请注意，没有办法强制潜在线程停止工作-Hystrix在JVM上可以做的最好的事情就是将其抛出InterruptedException。如果Hystrix封装的工作不遵守InterruptedExceptions，尽管客户端已经收到TimeoutException，Hystrix线程池中的线程仍将继续工作。尽管负载已“正确释放”，但此行为可能会使Hystrix线程池饱和。大多数Java HTTP客户端库不解释InterruptedExceptions。因此，请确保在HTTP客户端上正确配置连接和读取/写入超时。如果命令没有抛出任何异常，然后它会返回一个响应，则Hystrix在执行一些日志记录和监控报告后将返回此响应。对于run，Hystrix返回一个Observable，它发出单个响应，然后发出一个 onCompleted通知；对于 construct() ，Hystrix返回的是 construct()返回的Observable。 7.计算电路健康Hystrix 向断路器 报告成功，失败，拒绝和超时，断路器保持滚动一个计数器来计算统计信息。它使用这些统计信息来确定断路器什么时候应该跳闸，这时他会将随后所有请求短路，直到经过恢复期为止，在此之后，在首先检查某些运行状况检查后，它将在此闭合电路。 8. 获取后备（Get the Fallback）Hystrix tried to revert to your fallback whenever a command execution fails: Hystrix尝试在命令执行失败时回复到您的后备状态： 当construct（）或run（）抛出异常时（6.） 当命令由于电路断开而短路时（4.） 命令的线程池和队列或信号量达到最大容量（5.） 命令超过其超时长度时。 编写您的后备，以从内存缓存中或者通过其他的静态逻辑提供通用的响应，而无需任何网络依赖性。如果你在后备中必须使用网络调用，您应该通过HystrixCommand 或 HystrixObservableCommand 来使用。 对于 HystrixCommand，要提供后备逻辑，请实现HystrixCommand.getFallback())，它将会返回一个后备值。 对于HystrixObservableCommand，要提供后备逻辑，您可以实现HystrixObservableCommand.resumeWithFallback())，它返回一个Observable，它可能会发出一个或多个后备值。 如果fallback方法返回响应，则Hystrix将将此响应返回给调用方。如果是HystrixCommand.getFallback()，它将返回一个Observable，该Observable发出从方法返回的值。对于HystrixObservableCommand.resumeWithFallback()，它将返回从方法返回的相同Observable。 如果尚未为Hystrix命令实现后备方法，或者后备本身引发异常，则Hystrix仍会返回一个Observable，但它不发出任何内容并立即以onError通知终止。通过此onError通知，导致命令失败的异常被发送回调用者。 （实施回退实现可能会失败，这是一个糟糕的做法。您应该实施回退，以使其不执行任何可能失败的逻辑。） 后备失败或不存在的后备结果将因调用Hystrix命令的方式而异： execute() — 抛出异常 queue() — 成功返回 Future，但是这个 Future如果调用get()方法时候将会抛出异常 observe() — 返回一个 Observable ，当你订阅它时，将通过调用订阅者的onError 方法立刻终止 toObservable() — 返回一个 Observable ，当您订阅它时，将通过调用订阅者的onError 方法终止 9.返回成功的响应如果Hystrix命令成功执行，它将以Observable的形式将一个或多个响应返回给调用方。根据您在上述第2步中调用命令的方式，此Observable可能会在返回给您之前进行转换： execute() — 以与.queue() 相同的方式获取Future，然后在此Future调用get以获取Observable 发出的单个值。 queue() — 将 Observable 转换为 BlockingObservable ，以便于可以将其转换成一个 Future，然后返回Future。 observe() — 立即定于 Observable 并开始执行命令的流程；返回一个 Observable ，当您 subscribe（订阅） 它时候，将重新发出和通知。 toObservable() — 不变地返回 Observable ； 您必须 subscribe（订阅） 它，才能真正开始真正执行命令的流程。 时序图@adrianb11 has kindly provided a sequence diagram demonstrating the above flows.（Note: 需要梯子喔。） 参考上面，自己也有手撸了一个： 断路器（熔断器）下面展示了 HystrixCommand 或者 HystrixObservableCommand 如何与 HystrixCircuitBreaker 交互，以及其逻辑和决策流程，包括计数器在断路器中的行为方式。 电路打开和闭合的精确方式如下： 假设电路上的容量达到某个阈值(HystrixCommandProperties.circuitBreakerRequestVolumeThreshold())… 并假设误差百分比超过阈值误差百分比(HystrixCommandProperties.circuitBreakerErrorThresholdPercentage())… 断路器从 CLOSED 状态转换成 OPEN状态。 当它断开时，它会使针对该断路器的所有请求短路。 一段时间后(HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds())，下一个单个请求被允许通过（这是HALF-OPEN(半开)状态）。如果请求失败，断路器将在睡眠窗口期间返回OPEN状态。如果请求成功，断路器将切换到CLOSED 然后回到1.中的逻辑。 隔离（Isolation）Hystrix使用隔板模式将依赖关系彼此隔离，并限制对其中任何一个的并发访问。 线程和线程池客户端（库，网络调用等）在单独的线程上执行。这样可以将它们与调用线程（Tomcat线程池）隔离，以便调用者可以“摆脱”花费太长时间的依赖项调用。 Hystrix使用单独的，每个依赖关系的线程池作为约束任何给定依赖关系的方式，因此对基础执行的延迟将仅使该池中的可用线程饱和。 您可以在不使用线程池的情况下防止失败，但这需要信任的客户端非常快速地失败（网络连接/读取超时和重试配置），并且始终表现良好。 Netflix在Hystrix的设计中选择使用线程和线程池来实现隔离的原因很多，其中包括： 许多应用程序会针对许多不同团队开发的数十种不同服务执行数十种（有时甚至超过100种）不同的后端服务调用。 每个服务都提供自己的客户端库。 客户端库一直在变化 客户端库逻辑可以更改以添加新的网络调用。 客户端库可以包含诸如重试，数据解析，缓存（内存中或跨网络）之类的逻辑，以及其他此类行为。 客户端库往往是“黑匣子”-用户对其实现细节，网络访问模式，配置默认值等不透明。 在实际的几次生产中断中，确定为“哦，某些更改并且应该调整属性”或“客户端库更改了其行为”。 即使客户端本身没有变化，服务本身也会发生变化，从而影响性能特征，进而导致客户端配置无效 传递依赖关系可能会引入其他意外的客户端库，这些客户端库可能不是预期的，而且配置可能不正确。 大部分的网络访问是同步进行。 故障和延迟也可能在客户端代码中发生，而不仅仅是在网络调用中。 线程池的好处通过自己线程池中的线程进行隔离的好处是： 该应用程序受到完全保护，不受客户端库的攻击。给定依赖库的池可以填满，而不会影响应用程序的其余部分。 该应用程序可以接受风险更低的新客户端库。如果发生问题，它将隔离到库中，并且不会影响其他所有问题。 当发生故障的客户端再次恢复正常运行时，线程池将被清除，应用程序将立即恢复运行正常的性能，与整个Tomcat容器不堪重负的长时间恢复相反。 如果客户端库配置错误，线程池的运行状况将迅速证明这一点（通过增加错误，延迟，超时，拒绝等），您可以处理它（通常通过动态属性实时进行）而不会影响应用程序功能。 如果客户端服务更改了性能特征（通常会经常出现问题），进而导致需要调整属性（增加/减少超时，更改重试次数等），则可以通过线程池指标（错误，延迟）再次看到该特征，超时，拒绝），并且可以在不影响其他客户端，请求或用户的情况下进行处理。 除了隔离优势之外，拥有专用线程池还可以提供内置的并发性，可以利用这些并发性在同步客户端库之上构建异步外观（类似于Netflix API如何在Hystrix命令之上构建一个reactive，采用完全异步的Java API）。 简而言之，线程池提供的隔离允许客户端库和子系统性能特征的不断变化和动态组合得到优雅处理，而不会造成中断。 注意：尽管有单独的线程提供了隔离，但您的基础客户端代码也应具有超时和/或对线程中断的响应，因此它不能无限期地阻塞并使Hystrix线程池饱和。 线程池的缺点线程池的主要缺点是它们增加了计算开销。每个命令执行都涉及在单独的线程上运行命令所涉及的队列，调度和上下文切换。 Netflix API使用线程隔离每天处理10+亿次Hystrix Command执行。每个API实例有40多个线程池，每个线程池中有5-20个线程（大多数设置为10）。 线程的成本 在中位数（或更低）处，拥有一个单独的线程没有成本。 在第90个百分位数处，拥有一个单独的线程需要花费3ms的时间。 在第99个百分位数处，拥有一个单独的线程要花费9ms。但是请注意，成本的增加远远小于单独线程（网络请求）的执行时间的增加，后者从2跳到28，而成本从0跳到9。 对于这样的电路，这种开销在90％或更高的百分比上被认为对于大多数Netflix用例都是可以接受的，以实现所具有的弹性。 对于包装延迟非常低的请求的电路（例如那些主要访问内存缓存的请求），开销可能会过高，在这种情况下，您可以使用另一种方法，例如可尝试的信号量，尽管它们不允许超时，提供最大的弹性优势，而没有开销。但是，总的来说开销很小，以至于Netflix实际上通常比这种技术更喜欢使用单独线程的隔离优势。 信号灯（Semaphores）您可以使用信号量（或计数器）将并发调用的数量限制为任何给定的依赖项，而不是使用线程池/队列大小。这使Hystrix无需使用线程池就可以减轻负载，但它不允许超时和退出。如果您信任客户端，并且只希望减少负载，则可以使用这种方法。 HystrixCommand and HystrixObservableCommand 在2个地方支持信号灯: Fallback: Hystrix检索回退时，总是在调用Tomcat线程上进行回退。 Execution: 如果将属性execution.isolation.strategy设置为SEMAPHORE，则Hystrix将使用信号量而不是线程来限制调用该命令的并发父线程的数量 您可以通过定义可以执行多少个并发线程的动态属性来配置信号灯的这两种用法。您应该使用与确定线程池大小时相似的计算方法来确定它们的大小（在不到毫秒的时间内返回的内存中调用的性能可以超过5000rps，并且信号量仅为1或2…但默认值为10）。 注意：如果依赖关系被信号量隔离，然后变为潜在状态，则父线程将保持阻塞状态，直到基础网络调用超时为止。 一旦达到限制，信号灯拒绝将开始，但是填充信号灯的线程无法终止。 请求折叠（Request Collapsing）您可以在HystrixCommand前面加上请求折叠程序（HystrixCollapser是抽象父级），您可以将多个请求折叠为一个后端依赖项调用。 下图显示了两种情况下的线程和网络连接数：首先是没有连接，然后是请求折叠（假设所有连接在较短的时间范围内（在这种情况下为10ms）在“并发”状态）。 请求折叠-时序图@adrianb11 has kindly provided a sequence diagram of request-collapsing（Note: 需要梯子喔。）同样手撸一个图，如果想了解大概流程，可以参考上面的链接： 为什么使用请求折叠使用请求折叠可减少执行并发HystrixCommand执行所需的线程数和网络连接数。请求折叠以一种自动化的方式完成，不会强制所有代码库的开发人员协调手动的请求批处理。 全局上下文 (Across All Tomcat Threads)理想的折叠类型是在全局应用程序级别完成的，因此可以将来自任何Tomcat线程上任何用户的请求一起折叠。 例如，如果将HystrixCommand配置为支持对检索电影分级的依赖项的所有用户的批处理，则当同一JVM中的任何用户线程发出这样的请求时，Hystrix都会将其请求与其他任何请求一起添加到同一JVM中网络通话崩溃。 请注意，折叠器会将单个HystrixRequestContext对象传递给折叠的网络调用，因此下游系统必须处理这种情况才能使其成为有效的选择。 用户请求的上下文 (Single Tomcat Thread)如果将HystrixCommand配置为仅处理单个用户的批处理请求，则Hystrix可以折叠单个Tomcat线程（请求）中的请求。 例如，如果用户想为300个视频对象加载书签，而不是执行300个网络调用，Hystrix可以将它们全部合并为一个。 对象建模和代码复杂度有时，当您创建对对象的使用者具有逻辑意义的对象模型时，与对象的生产者的有效资源利用并不十分匹配。 例如，给定一个300个视频对象的列表，对其进行迭代并在每个对象上调用getSomeAttribute()是一个显而易见的对象模型，但是如果天真地实现了，则可能会导致300个网络调用之间相互之间的毫秒数（并且很可能会占用资源）。 有一些手动方法可以处理此问题，例如在允许用户调用getSomeAttribute()之前，要求他们声明要为其获取属性的视频对象，以便可以全部提取它们。 或者，您可以划分对象模型，以便用户必须从一个地方获取视频列表，然后从其他地方询问该视频列表的属性。 这些方法可能导致笨拙的API和对象模型与思维模型和使用模式不匹配。当多个开发人员在一个代码库上工作时，它们还可能导致简单的错误和效率低下，因为针对一个用例进行的优化可能会因另一用例的实现和代码的新路径而中断。 通过将折叠逻辑推到Hystrix层，无论如何创建对象模型，以什么顺序进行调用，或者不同的开发人员是否知道已完成优化或什至需要完成优化都无关紧要. 可以将getSomeAttribute()方法放在最合适的位置，并以适合使用模式的任何方式调用它，然后折叠器将自动将调用批量处理到时间窗口中。 请求折叠的成本是多少启用请求折叠的代价是在执行实际命令之前增加了等待时间。最大成本是批处理窗口的大小。 如果您有一条命令需要花费5ms的中位数执行时间和10ms的批处理窗口，则在最坏的情况下执行时间可能变为15ms。通常，一个请求不会在打开时就被提交到窗口，因此中值损失是窗口时间的一半，在这种情况下为5ms。 确定此成本是否值得取决于所执行的命令。高延迟命令不会受到少量额外平均延迟的影响。同样，给定命令的并发量很关键：如果很少有超过1或2个请求被批处理在一起，那么付出代价是没有意义的。实际上，在单线程顺序迭代中，折叠将是主要的性能瓶颈，因为每次迭代将等待10ms的批处理窗口时间。 但是，如果特定命令被大量同时使用，并且可以将数十个甚至数百个呼叫分批处理。然后，由于Hystrix减少了所需的线程数以及与依存关系的网络连接数，因此获得的吞吐量通常远远超过了成本。 折叠流程图 请求缓存HystrixCommand和HystrixObservableCommand实现可以定义一个缓存键，然后将其用于以并发感知的方式对请求上下文中的重复数据进行重复数据删除。 这是一个示例流程，涉及一个HTTP请求生命周期和两个在该请求中工作的线程： 请求缓存的好处是： 不同的代码路径可以执行Hystrix命令，而无需担心重复的工作。 这在大型代码库中特别有用，在该代码库中许多开发人员正在实现不同的功能。 例如，所有需要获得用户的Account对象的代码的多个路径都可以这样请求： 12345Account account = new UserGetAccount(accountId).execute();//orObservable&lt;Account&gt; accountObservable = new UserGetAccount(accountId).observe(); Hystrix RequestCache将一次且仅执行一次基础run()方法，并且尽管实例化了不同的实例，但执行HystrixCommand的两个线程仍将接收相同的数据。 整个请求中的数据检索都是一致的。 不是每次执行命令时都可能返回不同的值（或回退），而是对同一请求内的所有后续调用进行缓存并返回第一个响应。 消除重复线程执行 由于请求缓存位于construct()或run()方法调用的前面，因此Hystrix可以在导致线程执行之前对重复数据删除重复数据。 如果Hystrix没有实现请求缓存功能，则每个命令都需要自己在construct()或run()方法内部实现它，这会将其放在线程排队和执行之后。]]></content>
      <tags>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Netty in Action》 读后感]]></title>
    <url>%2F2020%2F02%2F07%2FNetty-in-Action-After-Reading%2F</url>
    <content type="text"><![CDATA[开编我想说 刻意练习，本着课本的例子，照着我也写一遍的原则进行练习。 基础知识真的太重要，很多基础知识是会影响我们阅读书的效果，甚至可能会误解书本的原意。就拿着当前阅读的书来说起，如果我们不知道计算机操作系统基础，不知Java网络编程基础，不知网络协议等，那么我们看书可能会举步维艰。所以，在看本书之前，我尝试查阅一些相关资料，以补充能够更好吸收书本知识。 本文章，就是书本很多地方的内容，并未能深刻理解，一本书的内容也不可能全部呈现。例如，零拷贝，各种网络协议的理解，例如tcp，udp协议等。很多基础内容，都感觉相对薄弱，所以日后需要加强基础的部分。 看完，你可能会有以下收获： Netty核心组件、重新认识字节、关于Netty单元测试、编码器和解码器、WebSocket简单的聊天室 阅读前的预习，大有裨益 同步和异步的概念 同步，是一个可靠的有序操作，例如，有顺序执行操作A-&gt;操作B，如果操作A没有完成返回，操作B需要排队等候；反之，异步则相反无需等待，通常可以依靠回调或者事件的方式来进行操作的次序的问题。 堵塞和非堵塞 在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。 查询常见的I/O模型：I/O堵塞;I/O非堵塞;I/O复用；信号驱动I/O；异步I/O 用户空间和系统空间 现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。摘抄自这里 Linux 操作系统中select、poll、epoll详细内容可以查看 High-Performance I/O Design Patterns详细内容可以看 概述 Netty is an asynchronous event-driven network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients. 从上面我抽取了三个关键词，asynchronous、event-driven、high performance。带着三个关键信息，看能够从书中摄取到三个核心的内容。 核心内容核心组件Channel Channel，是出入站数据的载体，或者是网络中Socket抽象代表。目的：Channel为了降低直接使用Java中Socket API的复杂度。 Channel的生命周期：register-&gt;active-&gt;inactive-&gt;unregistred EventLoop 用于处理连接的生命周期的中发生的事件 Channel、EventLoop和EventLoopGroup的关系图 图中可以看到EventLoopGroup其实就具有多个EventLoop的组，EventLoop会在Channel的整个生命周期处理I/O事件。三者关系如下： 一个EventLoopGroup包含一个或者多个EventLoop 一个EventLoop一个生命周期中，只和一个线程绑定 EventLoop所有I/O处理事件，将有专用的线程处理 一个Channel生命周期，只会注册到一个EventLoop上 一个EventLoop可以会分配多个Channel 得益于EventLoop是一个固定的线程处理，给定的Channel上的I/O的处理将会在同一个线程处理，避免了不必要的线程切换上下文的开销； 下面来深入了解一下，EventLoop：先通过类图去纵览 java.util.concurrentAbstractExecutorService主要是实现了ExecutorService接口，ScheduledExecutorService则是继承了ExecutorService； io.netty.utilconcurrentAbstractEventExecutor，继承了AbstractExecutorService类，并且实现EventExecutor接口， io.netty.channelEventLoop，继承了OrderedEventExecutor, EventLoopGroup，只有一个：EventLoopGroup parent()方法。SingleThreadEventLoop，继承SingleThreadEventExecutor，并且实现EventLoop接口；重头戏来了，NioEventLoop，是继承了SingleThreadEventLoop，正如上面所说的：一个EventLoop一个生命周期中，只和一个线程绑定 EventLoop的执行逻辑： ChannelPipeline pipeline，意译为管道，ChannelPipeline，一看到这个名字，我们能够猜到它的作用就是类似管道的作用。目的：为了提供ChannelHandler链式容器（ChannelHandler在下一节介绍） 本节，需要了解pipeline它的头部和尾部的概念，入站从头部第一个ChannelHandler先入，出站的时候从尾端端第一个ChannelHandler先开始流出。 顺便提一下，Channel一旦分配为ChannelPipeline后，是永久性操作，不能被修改。通过 DefaultChannelPipeline 和 AbstractChannel 源代码分析，也能得到上面的结论： 12345AbstractChannel protected AbstractChannel(Channel parent) &#123; ... pipeline = newChannelPipeline();// 新建分配一个ChannelPipeline &#125; 12345DefaultChannelPipeline protected DefaultChannelPipeline(Channel channel) &#123; ... this.channel = ObjectUtil.checkNotNull(channel, "channel"); &#125; 最后，上面的设计使得，我们 变动（增删改） ChannelPipeline上的Handler也是相当方便的。 ChannelHandler ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler生命周期：added-&gt;removed (excption)通过ChannelHandler再来看出入站的概念：入站，就是数据流要进行我们的服务前置的业务处理。出站，就是我们需要返回数据流时候的后置业务处理。当然我们还是需要谨记，上一节的pipeline的头部和尾端的概念，不然会容易出或者入站的handler出现位置不对的情况。 ChannelInboundHandler 入站处理器接口，处理入站数据和状态变化列出我在练习中常用的方法： 类 型 描 述 channelRegistered 当Channel已经注册到它的EventLoop并且能够处理I/O时被调用 channelUnregistered 当Channel从它的EventLoop注销并且无法处理任何I/O时被调用 channelActive 当Channel处于活动状态时被调用；Channel已经连接/绑定并且已经就绪 channelInactive 当Channel离开活动状态并且不再连接它的远程节点时被调用 channelReadComplete 当Channel上的一个读操作完成时被调用 channelRead 当从Channel读取数据时被调用 userEventTriggered 当ChannelnboundHandler.fireUserEventTriggered()方法被调用时被调用，因为一个POJO被传经了ChannelPipeline 我们可以通过继承 ChannelInboundHandlerAdapter 来编写自己的入站处理器。常用的是：SimpleChannelInboundHandler，因为它给我优化了一些常用的操作，例如，资源的自动释放等 异常处理：exceptionCaught，这个方法在 ChannelInboundHandlerAdapter 已经标记被弃用， ChannelOutboundHandler 出站处理器接口，处理出站的所有数据，并且能够拦截所有的操作。列出我在练习中常用的方法： 类 型 描 述 bind(ChannelHandlerContext,SocketAddress,ChannelPromise) 当请求将Channel绑定到本地地址时被调用 connect(ChannelHandlerContext,SocketAddress,SocketAddress,ChannelPromise)当 请求将Channel连接到远程节点时被调用 disconnect(ChannelHandlerContext,ChannelPromise) 当请求将Channel从远程节点断开时被调用 close(ChannelHandlerContext,ChannelPromise) 当请求关闭Channel时被调用 deregister(ChannelHandlerContext,ChannelPromise) 当请求将Channel从它的EventLoop注销时被调用 read(ChannelHandlerContext) 当请求从Channel读取更多的数据时被调用 flush(ChannelHandlerContext) 当请求通过Channel将入队数据冲刷到远程节点时被调用 write(ChannelHandlerContext,Object,ChannelPromise) 当请求通过Channel将数据写到远程节点时被调用 异常处理：两种方式： 在出站操作都会返回ChannelFuture，进行添加监听事件 在ChannelOutboundHandler的入参都会带有ChannelPromis，进行添加监听事件方式2更加常用，因为相对方式1相关更加简单有效。 ChannelHandlerContext紧接上面，我来看一下Channel、ChannelPipeline、ChannelHandler和ChannelHandlerContext之间的关系：当ChannelHandler添加到ChannelPipeline到时候，ChannelHandlerContext将会被创建。 ChannelHandler高级用法：我们可以在使用ChannelHandler可以缓存ChannelHanlderContext，然后去完成一些复杂的操作。但是这里是有一个前提，就是当前ChannelHandler应该是被@Sharable注释，因为一个ChannelHandler可能属于多个ChannelPipeline。在使用@Sharable之前，最好确保当前ChannelHandler是线程安全。 ChannelFuture Netty提供了ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时（无论是否成功）得到通知。 Bootstrap 引导客户端 和 无连接协议引导流程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public final class EchoClient &#123; static final boolean SSL = System.getProperty("ssl") != null; static final String HOST = System.getProperty("host", "127.0.0.1"); static final int PORT = Integer.parseInt(System.getProperty("port", "8023")); public static void main(String[] args) throws Exception &#123; // Configure SSL.git final SslContext sslCtx; if (SSL) &#123; sslCtx = SslContextBuilder.forClient() .trustManager(InsecureTrustManagerFactory.INSTANCE).build(); &#125; else &#123; sslCtx = null; &#125; // Configure the client. EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT)); &#125; p.addLast( new CustomSimpleChannelInboundHandler()) ; &#125; &#125;); // 在connect方法调用后，Bootstrap类将会创建一个新的Channel ChannelFuture f = b.connect(HOST, PORT).sync(); // Wait until the connection is closed. f.channel().closeFuture().sync(); &#125; finally &#123; // Shut down the event loop to terminate all threads. group.shutdownGracefully(); &#125; &#125;&#125; 引导服务器 引导流程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final class EchoServer &#123; static final boolean SSL = System.getProperty("ssl") != null; static final int PORT = Integer.parseInt(System.getProperty("port", "8007")); public static final String SECOND_HANDLER_NAME = "second"; public static void main(String[] args) throws Exception &#123; // Configure SSL. final SslContext sslCtx; if (SSL) &#123; SelfSignedCertificate ssc = new SelfSignedCertificate(); sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(); &#125; else &#123; sslCtx = null; &#125; // Configure the server. EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(2); final EchoServerHandler serverHandler = new EchoServerHandler(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc())); p.addLast(serverHandler); &#125; &#125;); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync(); &#125; finally &#123; // Shut down all event loops to terminate all threads. bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 引导DatagramChannelNetty提供了各种DatagramChannel的实现，它唯一的区别就是不能使用connect方法，只能调用bind方法。 如何优雅关闭客户端和服务端 我主要需要关闭我们创建EventLoopGroup，我们可以通过123456789```java @Override public Future&lt;?&gt; shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) &#123; for (EventExecutor l: children) &#123; l.shutdownGracefully(quietPeriod, timeout, unit); &#125; return terminationFuture(); &#125; 重新认识字节 The byte is a unit of digital information that most commonly consists of eight bits. Historically, the byte was the number of bits used to encode a single character of text in a computer and for this reason it is the smallest addressable unit of memory in many computer architectures记住：8 bit = 1 byte 为啥说重新认识了字节，因为自己在学习ByteBuf的时候犯了一些低级的错误（单元测试将呈现我的低级错误），反应出来自己的基础还是不够牢固。下面这通过练习的例子，来认识一下Netty强大的字节容器：ByteBuff ByteBuff，实现原理有两个索引指针，一个用于读取（readerIndex），一个用于写入（writerIndex）。 下面的例子详细说，不同ByteBuff的使用模式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class ByteBuffExample &#123; public static final String HI_BYTE_BUFF = "Hi! ByteBuff."; private static final ByteBuf heapBuff = Unpooled.copiedBuffer(HI_BYTE_BUFF, CharsetUtil.UTF_8); public static final Charset UTF_8 = CharsetUtil.UTF_8; public static void main(String[] args) &#123; // 堆缓冲区 System.out.println("==================heap buff=================="); heapByteBuff(); System.out.println("==================direct buff=================="); directByteBuff(); System.out.println("==================composite buff=================="); compositeByteBuff(); System.out.println("==================read and write=================="); readAndWrite(); System.out.println("==================ByteBufHolder=================="); byteBuffHolder(); &#125; /** * 存储在 JVM 堆空间中，这种模式被成为支撑数据（backing array） */ public static void heapByteBuff() &#123; if (heapBuff.hasArray()) &#123; byte[] array = heapBuff.array(); int offset = heapBuff.arrayOffset() + heapBuff.readerIndex(); int length = heapBuff.readableBytes(); byte[] target = new byte[length]; System.arraycopy(array, offset, target, 0, length); System.out.println(new String(target)); &#125; &#125; /** * 直接缓冲区是另外一种ByteBuf模式。 * 我们期望用于对象创建的内存分配永远都来自于堆中， * 但这并不是必须的——NIO在JDK1.4中引入的ByteBuffer类允许JVM实现通过本地调用来分配内存。 * 这主要是为了避免在每次调用本地I/O操作之前（或者之后） * 将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。 * * 它的缺点主要： * 1. 分配和释放表昂贵 * 2. 如果在处理预留代码的时候，可能不得不又复制一遍。 * * 建议：如果在知道数据将被作为数据来访问的时候，我们更加推荐使用 堆内存 。 * */ private static void directByteBuff() &#123; ByteBuf directBuffer = Unpooled.directBuffer().writeBytes(heapBuff); // 检查buf是否有数组，如果不是，则说明一个直接堆缓冲区 if (!directBuffer.hasArray()) &#123; int readerIndex = directBuffer.readerIndex(); int length = directBuffer.readableBytes(); byte[] array = new byte[length]; directBuffer.getBytes(readerIndex, array); System.out.println(new String(array)); &#125; &#125; /** * 复合缓冲区，它提供一种聚合模式给我们使用。例如我需要组合一个协议， * 我们需要一部分装配头部信息，一部分装配主体信息。 */ private static void compositeByteBuff() &#123; CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer(); ByteBuf headBuf = Unpooled.copiedBuffer("Hi! ", CharsetUtil.UTF_8); ByteBuf bodyBuf = Unpooled.copiedBuffer("ByteBuff.", CharsetUtil.UTF_8); compositeByteBuf.addComponents(headBuf, bodyBuf); System.out.println("compositeByteBuf.removeComponent(0) before:"); for (ByteBuf byteBuf : compositeByteBuf) &#123; System.out.println(byteBuf.toString(CharsetUtil.UTF_8)); &#125; System.out.println("compositeByteBuf.removeComponent(0) after:"); compositeByteBuf.removeComponent(0); for (ByteBuf byteBuf : compositeByteBuf) &#123; System.out.println(byteBuf.toString(CharsetUtil.UTF_8)); &#125; &#125; /** * 主要是一些字节操作API的使用。 */ private static void readAndWrite() &#123; ByteBuf byteBuf = Unpooled.copiedBuffer(HI_BYTE_BUFF, CharsetUtil.UTF_8); System.out.println(byteBuf.toString(CharsetUtil.UTF_8)); // slice，分片，但是不会修改索引信息 ByteBuf slice = byteBuf.slice(0, 3); // 拷贝操作，不影响原对象 ByteBuf copy = byteBuf.copy(0, 3); assert !ByteBufUtil.equals(slice, copy); System.out.println(slice.toString(CharsetUtil.UTF_8)); byteBuf.setByte(0, ((byte) 'J')); copy.setByte(0, ((byte) 'W')); assert byteBuf.getByte(0) == slice.getByte(0); assert copy.getByte(0) != byteBuf.getByte(0); System.out.println(((char) byteBuf.getByte(0))); int readerIndex = byteBuf.readerIndex(); int writerIndex = byteBuf.writerIndex(); byteBuf.setByte(1, ((byte) 'B')); System.out.println(((char) byteBuf.getByte(1))); assert readerIndex == byteBuf.readerIndex(); assert writerIndex == byteBuf.writerIndex(); // 写一个字节，将会影响writerIndex索引。 byteBuf.writeByte(((byte) '?')); assert readerIndex == byteBuf.readerIndex(); assert writerIndex != byteBuf.writerIndex(); &#125; private static void byteBuffHolder() &#123; ByteBufHolder byteBufHolder = new DefaultByteBufHolder(Unpooled.copiedBuffer(HI_BYTE_BUFF, UTF_8)); ByteBuf content = byteBufHolder.copy().content(); content.setByte(0, ((byte) 'W')); System.out.println("source: " + ((char) heapBuff.getByte(0))); System.out.println("new: " + ((char) content.getByte(0))); &#125;&#125; 解码器和编码器解码器总体来说，我们有两种需求： 字节解码成消息，常用抽象类：ByteToMessageDecoder extends ChannelInboundHandlerAdapter 消息A解码成消息B，常用抽象类：MessageToMessageDecoder extends ChannelInboundHandlerAdapter它们都是继承 ChannelInboundHandlerAdapter，又是熟悉的味道，这个又是得益Netty统一的设计。流程图如下： 编码器总体来说，我们有两种需求： 消息编码成消息，常用抽象类：MessageToByteEncoder extends ChannelOutboundHandlerAdapter 消息B编码成消息A，常用抽象类：MessageToMessageEncoder extends ChannelOutboundHandlerAdapter它们都是继承了ChannelOutboundHandlerAdapter。流程图如下： 抽象的编解码类很多时候，编解码是一对，我们就想着为啥不能直接设置成一个类？Netty给我们，预设Codec。 字节编解码成消息，ByteToMessageCodec extend ChannelDuplexHandler 消息编解码成消息，MessageToMessageCodec extend ChannelDuplexHandlerChannelDuplexHandler extends ChannelInboundHandlerAdapter implements ChannelOutboundHandler HttpObjectAggregator 源码分析12HttpObjectAggregator extends MessageAggregator&lt;HttpObject, HttpMessage, HttpContent, FullHttpMessage&gt; 核心逻辑其实是在 MessageAggregator 中 decode 方法中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130@Override protected void decode(final ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out) throws Exception &#123; assert aggregating; // HttpObjectAggregator.isStartMessage: // return msg instanceof HttpMessage; if (isStartMessage(msg)) &#123; handlingOversizedMessage = false; if (currentMessage != null) &#123; currentMessage.release(); currentMessage = null; throw new MessageAggregationException(); &#125; @SuppressWarnings("unchecked") S m = (S) msg; // Send the continue response if necessary (e.g. 'Expect: 100-continue' header) // Check before content length. Failing an expectation may result in a different response being sent. Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline()); if (continueResponse != null) &#123; // Cache the write listener for reuse. // 缓存起来监听器方便重用，监听器作用：如果调用不成功，则调用fireExceptionCaught方法，抛出异常 ChannelFutureListener listener = continueResponseWriteListener; if (listener == null) &#123; continueResponseWriteListener = listener = new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; if (!future.isSuccess()) &#123; ctx.fireExceptionCaught(future.cause()); &#125; &#125; &#125;; &#125; // Make sure to call this before writing, otherwise reference counts may be invalid. boolean closeAfterWrite = closeAfterContinueResponse(continueResponse); handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse); final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener); if (closeAfterWrite) &#123; future.addListener(ChannelFutureListener.CLOSE); return; &#125; if (handlingOversizedMessage) &#123; return; &#125; &#125; else if (isContentLengthInvalid(m, maxContentLength)) &#123; // if content length is set, preemptively close if it's too large invokeHandleOversizedMessage(ctx, m); return; &#125; if (m instanceof DecoderResultProvider &amp;&amp; !((DecoderResultProvider) m).decoderResult().isSuccess()) &#123; O aggregated; if (m instanceof ByteBufHolder) &#123; // retain方法：将引用增加+1（Netty中，如果引用值为0，则会被回收），以防止被回收 // 开始聚合操作由子类实现对应的操作 aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain()); &#125; else &#123; aggregated = beginAggregation(m, EMPTY_BUFFER); &#125; // 完成聚合操作，finishAggregation0 中调用了 finishAggregation,其中finishAggregation由子类实现。 // HttpObjectAggregator中实现了，增加了rfc2616 14.13 Content-Length 判断，如果没有响应体头部那样设置 'Content-Length'，则根据 aggregated.content().readableBytes() 设置一个值 finishAggregation0(aggregated); out.add(aggregated); return; &#125; // A streamed message - initialize the cumulative buffer, and wait for incoming chunks. CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents); if (m instanceof ByteBufHolder) &#123; appendPartialContent(content, ((ByteBufHolder) m).content()); &#125; currentMessage = beginAggregation(m, content); &#125; else if (isContentMessage(msg)) &#123; if (currentMessage == null) &#123; // it is possible that a TooLongFrameException was already thrown but we can still discard data // until the begging of the next request/response. return; &#125; // Merge the received chunk into the content of the current message. CompositeByteBuf content = (CompositeByteBuf) currentMessage.content(); @SuppressWarnings("unchecked") final C m = (C) msg; // Handle oversized message. if (content.readableBytes() &gt; maxContentLength - m.content().readableBytes()) &#123; // By convention, full message type extends first message type. @SuppressWarnings("unchecked") S s = (S) currentMessage; invokeHandleOversizedMessage(ctx, s); return; &#125; // Append the content of the chunk. appendPartialContent(content, m.content()); // Give the subtypes a chance to merge additional information such as trailing headers. aggregate(currentMessage, m); final boolean last; // 主要判断 是否为 最后的消息了，如果是最后的消息，将进行添加输出列表out中 if (m instanceof DecoderResultProvider) &#123; DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult(); if (!decoderResult.isSuccess()) &#123; if (currentMessage instanceof DecoderResultProvider) &#123; ((DecoderResultProvider) currentMessage).setDecoderResult( DecoderResult.failure(decoderResult.cause())); &#125; last = true; &#125; else &#123; last = isLastContentMessage(m); &#125; &#125; else &#123; last = isLastContentMessage(m); &#125; if (last) &#123; finishAggregation0(currentMessage); // All done out.add(currentMessage); currentMessage = null; &#125; &#125; else &#123; throw new MessageAggregationException(); &#125; &#125; 不可被忽略的单元测试1234567891011121314151617181920/** * AbsIntegerEncoder 测试类 * * @author wusonghui@bubi.cn * @date 2020-02-02 21:26 * @since 1.0.0 */public class AbsIntegerEncoder extends MessageToMessageEncoder&lt;ByteBuf&gt; &#123; @Override protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception &#123; // 这里就是我犯下的低级错误，当时没有想明白，为啥是4呢？ // 如果我们知道int是占4个字节，就很容易理解了。 // 也是从这里，让我反思。 while (msg.readableBytes() &gt;= 4) &#123; int value = Math.abs(msg.readInt()); out.add(value); &#125; &#125;&#125; 1234567891011121314151617public class AbsIntegerEncoderTest &#123; @Test public void testAbsIntegerEncoder() &#123; ByteBuf byteBuf = Unpooled.buffer(); for (int i = 0; i &lt; 10; i++) &#123; byteBuf.writeInt(i * -1); &#125; EmbeddedChannel channel = new EmbeddedChannel(new AbsIntegerEncoder()); Assert.assertTrue(channel.writeOutbound(byteBuf)); Assert.assertTrue(channel.finish()); for (int i = 0; i &lt; 10; i++) &#123; Assert.assertEquals(i, ((int) channel.readOutbound())); &#125; Assert.assertNull(channel.readOutbound()); &#125;&#125; 12345678910111213141516171819202122232425/** * 自定义待测试待 解码器 * * @author wusonghui@bubi.cn * @date 2020-02-02 20:56 * @since 1.0.0 */public class FixedLengthFrameDecoder extends ByteToMessageDecoder &#123; private final int frameLength; public FixedLengthFrameDecoder(int frameLength) &#123; if (frameLength &lt;= 0) &#123; throw new IllegalArgumentException("frameLength must be a positive integer: " + frameLength); &#125; this.frameLength = frameLength; &#125; @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; while (in.readableBytes() &gt;= frameLength) &#123; ByteBuf buf = in.readBytes(frameLength); out.add(buf); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class FrameChunkDecoderTest &#123; @Test public void testFrameChunkDecoderException() &#123; ByteBuf byteBuf = Unpooled.buffer(); for (int i = 0; i &lt; 10; i++) &#123; byteBuf.writeByte(i); &#125; ByteBuf input = byteBuf.duplicate(); EmbeddedChannel channel = new EmbeddedChannel(new FrameChunkDecoder(3)); Assert.assertTrue(channel.writeInbound(input.readBytes(2))); try &#123; channel.writeInbound(input.readBytes(4)); Assert.fail(); &#125; catch (Exception e) &#123; Assert.assertTrue(e instanceof TooLongFrameException); &#125; Assert.assertTrue(channel.writeInbound(input.readBytes(3))); Assert.assertTrue(channel.finish()); ByteBuf read = channel.readInbound(); Assert.assertEquals(byteBuf.readSlice(2), read); read.release(); read = channel.readInbound(); Assert.assertEquals(byteBuf.skipBytes(4).readSlice(3), read); read.release(); Assert.assertNull(channel.readInbound()); byteBuf.release(); &#125;&#125; 网络协议使用WebSocket WebSocket ，WebSocket协议是完全重新设计的协议，旨在为Web上的双向数据传输问题提供一个切实可行的解决方案，使得客户端和服务器之间可以在任意时刻传输消息，因此，这也就要求它们异步地处理消息回执。 使用WebSocket实现一个简单的聊天室，总体架构图如下：服务器的流程图如下： 大概代码结构如下： 12345678910111213141516src├─main ├─java ├─handler ├─HttpRequestHandler ├─TextWebSocketFrameHandler ├─initializer ├─ChatServerInitializer ├─SecureChatServerInitializer ├─server ├─ChatServer ├─SecureChatServer ├─resource ├─index.html├─test├─pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import io.netty.channel.*;import io.netty.handler.codec.http.*;import io.netty.handler.ssl.SslHandler;import io.netty.handler.stream.ChunkedNioFile;import java.io.File;import java.io.FileNotFoundException;import java.io.RandomAccessFile;import java.net.URISyntaxException;import java.net.URL;/** * HttpRequestHandler * * @author wusonghui@bubi.cn * @date 2020-02-05 15:25 * @since 1.0.0 */public class HttpRequestHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; &#123; private final String wsUri; private static File INDEX; static &#123; URL location = HttpRequestHandler.class.getProtectionDomain().getCodeSource().getLocation(); String path; try &#123; path = location.toURI() + "index.html"; path = !path.contains("file:") ? path : path.substring(5); INDEX = new File(path); if (!INDEX.exists()) &#123; throw new FileNotFoundException("path :" + path + " not found"); &#125; &#125; catch (URISyntaxException | FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public HttpRequestHandler(String wsUri) &#123; this.wsUri = wsUri; &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception &#123; if (wsUri.equalsIgnoreCase(request.uri())) &#123; ctx.fireChannelRead(request.retain()); &#125; else &#123; if (HttpUtil.is100ContinueExpected(request)) &#123; send100Continue(ctx); &#125; RandomAccessFile file = new RandomAccessFile(INDEX, "r"); HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), HttpResponseStatus.OK); response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/html; charset=UTF-8"); boolean keepAlive = HttpUtil.isKeepAlive(request); if (keepAlive) &#123; response.headers().set(HttpHeaderNames.CONTENT_LENGTH, file.length()); response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE); &#125; ctx.write(response); if (ctx.pipeline().get(SslHandler.class) == null) &#123; ctx.write(new DefaultFileRegion(file.getChannel(), 0, file.length())); &#125; else &#123; ctx.write(new ChunkedNioFile(file.getChannel())); &#125; ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT); if (!keepAlive) &#123; future.addListener(ChannelFutureListener.CLOSE); &#125; &#125; &#125; private static void send100Continue(ChannelHandlerContext ctx) &#123; FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE); ctx.writeAndFlush(response); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.channel.group.ChannelGroup;import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;/** * TextWebSocketFrameHandler * * @author wusonghui@bubi.cn * @date 2020-02-05 15:58 * @since 1.0.0 */public class TextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123; private final ChannelGroup group; public TextWebSocketFrameHandler(ChannelGroup group) &#123; this.group = group; &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) &#123; ctx.pipeline().remove(HttpRequestHandler.class); group.writeAndFlush(new TextWebSocketFrame("Client " + ctx.channel() + " joined")); group.add(ctx.channel()); &#125; else &#123; super.userEventTriggered(ctx, evt); &#125; &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception &#123; group.writeAndFlush(msg.retain()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940import io.netty.channel.Channel;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.group.ChannelGroup;import io.netty.example.ws.handler.HttpRequestHandler;import io.netty.example.ws.handler.TextWebSocketFrameHandler;import io.netty.handler.codec.http.HttpObjectAggregator;import io.netty.handler.codec.http.HttpServerCodec;import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.stream.ChunkedWriteHandler;/** * ChatServerInitializer * * @author wusonghui@bubi.cn * @date 2020-02-05 16:08 * @since 1.0.0 */public class ChatServerInitializer extends ChannelInitializer&lt;Channel&gt; &#123; private final ChannelGroup group; public ChatServerInitializer(ChannelGroup group) &#123; this.group = group; &#125; @Override protected void initChannel(Channel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new HttpServerCodec()) .addLast(new ChunkedWriteHandler()) .addLast(new HttpObjectAggregator(64 * 1024)) .addLast(new HttpRequestHandler("/ws")) .addLast(new WebSocketServerProtocolHandler("/ws")) .addLast(new TextWebSocketFrameHandler(group)) .addLast(new LoggingHandler(LogLevel.INFO)) ; &#125;&#125; 123456789101112131415161718192021222324252627282930import io.netty.channel.Channel;import io.netty.channel.group.ChannelGroup;import io.netty.handler.ssl.SslContext;import io.netty.handler.ssl.SslHandler;import javax.net.ssl.SSLEngine;/** * SecureChatServerInitializer * * @author wusonghui@bubi.cn * @date 2020-02-05 21:38 * @since 1.0.0 */public class SecureChatServerInitializer extends ChatServerInitializer &#123; private final SslContext sslContext; public SecureChatServerInitializer(ChannelGroup channelGroup, SslContext sslContext) &#123; super(channelGroup); this.sslContext = sslContext; &#125; @Override protected void initChannel(Channel ch) throws Exception &#123; super.initChannel(ch); SSLEngine engine = sslContext.newHandler(ch.alloc()).engine(); engine.setUseClientMode(false); ch.pipeline().addFirst(new SslHandler(engine)); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.group.ChannelGroup;import io.netty.channel.group.DefaultChannelGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.example.ws.initializer.ChatServerInitializer;import io.netty.util.concurrent.ImmediateEventExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.net.InetSocketAddress;import java.util.Objects;/** * ChatServer * * @author wusonghui@bubi.cn * @date 2020-02-05 16:29 * @since 1.0.0 */public class ChatServer &#123; private final ChannelGroup channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE); private final EventLoopGroup bossGroup = new NioEventLoopGroup(1); private final EventLoopGroup workGroup = new NioEventLoopGroup(2); private Channel channel; protected final static String SERVER_PORT = System.getProperty("port", "9999"); private final static Logger logger = LoggerFactory.getLogger(ChatServer.class); protected ChannelFuture start() &#123; int port = Integer.parseInt(SERVER_PORT); ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workGroup) .channel(NioServerSocketChannel.class) .childHandler(createInitializer(channelGroup)); ChannelFuture future = serverBootstrap.bind(new InetSocketAddress(port)); future.syncUninterruptibly(); channel = future.channel(); Runtime.getRuntime().addShutdownHook(new Thread(this::destroy)); Objects.requireNonNull(future).channel().closeFuture().syncUninterruptibly(); if (future.isSuccess()) &#123; logger.info("Chat Server start, port: &#123;&#125;", port); &#125; else &#123; logger.info("Chat Server start failed, port: &#123;&#125;", port); &#125; return future; &#125; protected ChannelInitializer&lt;Channel&gt; createInitializer(ChannelGroup channelGroup) &#123; return new ChatServerInitializer(channelGroup); &#125; protected void destroy() &#123; if (channel != null) &#123; channel.close(); &#125; channelGroup.close(); bossGroup.shutdownGracefully(); workGroup.shutdownGracefully(); &#125; public static void main(String[] args) &#123; new ChatServer().start(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940import io.netty.channel.Channel;import io.netty.channel.ChannelInitializer;import io.netty.channel.group.ChannelGroup;import io.netty.example.ws.initializer.SecureChatServerInitializer;import io.netty.handler.ssl.SslContext;import io.netty.handler.ssl.SslContextBuilder;import io.netty.handler.ssl.util.SelfSignedCertificate;import javax.net.ssl.SSLException;import java.security.cert.CertificateException;/** * SecureChatServer * * @author wusonghui@bubi.cn * @date 2020-02-05 21:35 * @since 1.0.0 */public class SecureChatServer extends ChatServer &#123; private final SslContext sslContext; public SecureChatServer(SslContext sslContext) &#123; this.sslContext = sslContext; &#125; @Override protected ChannelInitializer&lt;Channel&gt; createInitializer(ChannelGroup channelGroup) &#123; return new SecureChatServerInitializer(channelGroup, sslContext); &#125; public static void main(String[] args) &#123; try &#123; SelfSignedCertificate certificate = new SelfSignedCertificate(); SslContext sslContext = SslContextBuilder.forServer(certificate.certificate(), certificate.privateKey()).build(); new SecureChatServer(sslContext).start(); &#125; catch (SSLException | CertificateException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最后聊聊连续差不多两周的学习，通过看书+练习的操作，让自己能够将书上的知识，真的运用起来，并且进一步加深理解。刻意练习真的太重要，如果光看不练，就是纸上谈兵。]]></content>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google's Elite Security Team, Project Zero]]></title>
    <url>%2F2020%2F01%2F04%2FGoogle-Elite-Security-Team-Project-Zero%2F</url>
    <content type="text"><![CDATA[阅读When Apple launched the iPhone through an exclusive partnership with AT&amp;T in 2007, seventeen-year-old George Hotz wanted to use an iPhone but not with AT&amp;T. He wanted to make calls through hsi own T-Mobile network, so he cracked AT&amp;T’s lock on the iPhone. Apple scrambled to fix the bug that allowed this, but offcially ignored George Hotz. Later in 2011, Hotz reverse engineered the Playstion 3 and posted a copy of the root keys on his website. Snoy sued him but settled after Hotz promise never to hack Sony products again. Then in early 2014, at Google’s hacking competition, Hotz discovered a security hole in Google’s Chrome OS. The company gave him $150,000 reward. Two months later, Google’s security engineer Chris Evans offered him a position in a team of elite hackers. George Hotz accepted the offer and now workds for Google’s security team Project Zero. Project Zero worked in secret until Google publically revealed the team in July 2014. Its sole mission is tracking down and getting rid of security flaws in the world’s software. These flaws are called zero-day vulnerabilities, which are a common target of cyber criminals. Project Zero’s hackers aren’t just looking into the products that Google makes. They are free to hack any software in the world. Why? They want to make a safer Internet for everyone. The team’s plicy is simple. The team notifies vendors of vulnerabilities immediately, If fixes are not available within 90-days, bug reports automatically become available to the public. The 90-day diclosure policy appears to be working in most case. The Adobe Flash team fixed 37 Project Zero vulnerabilities(for 100%) within 90-day period. The Project Zero blog indicates that 85% of all velnerabilities are patched before the deadline. However, recently Google’s strict 90-day policy came under fire form Microsoft and Apple. The Project Zero ream publicly disclosed bugs which were present in Windows 8.1 and MacOS X before Microsoft and Apple released patches. Microsoft heavily criticized Google since the company was scheduled to realese a patch just two days later. Recently Google loosened its 90-day policy with an additional 14-day grace period. Now vendors have an addtional 14 days to patch vulnerabilities as long as the inform Google of the release schedule before the deadline. “People deserve to use the Internet without fear that vulnerabilities out there can ruin their privacy with a single website vistit. We’re goting to try to focus on the supply of these hight value vulnerabilities and elimnate them.” says Evans. 分析核心语法熟悉句式4 句式3为【主语 + 动词（vt） + 宾语】句式4为【主语 + 动词 + 宾语（间接宾语） + 宾语（直接宾语）】 The company gave him a reward.公司给他奖励。 Chris Evans offered him a position.克里斯·埃文斯提供给他一个职位。 The team notifies vendor of vulnerabilities.团队向厂商通报漏洞。中国式英语：The team notifies vendosrs vulnerablities.(X) They inform Google of the release schedule.他们向谷歌告知上线计划。中国式英语：They inform Google the release schedule.(X) 关系代名词that和which 关系代名词，连接两个句子，兼顾连词和代名词的作用。根据先行词和格种类不同，关系代名词也会相应发生变化。先行词，是修饰关系代名词从句的名词。格在关系代名词从句中发挥作用。 The team disclosed bugs. They were present in Windows 8.1.等同于：The team disclosed bugs that were present in Windows 8.1.The team disclosed bugs which were present in Windows 8.1. 先行词bugs指物，主语是they，此时用主格关系代名词that或者which。团队公布了bug，他们存在于Windows 8.1。 The hackers are looking into the products. Google makes them.等同于：The hackers are looking into the products that Google makes them.The hackers are looking into the products which Google makes them. 先行词the products指物，宾语是them，此时用主格关系代名词that或者which。黑客们调查产品谷歌制造的。 关系代名词引导非限定性定语从句熟悉关系代名词引导非限定性定语从句。这类词用于补充说明前文的内容。关系代名词前面加（,）可以理解为【连接词 + 代名词】，也是关系代名词引导非限定性定语从句和关系代名词引导限定性定语从句的区别，后面我们慢慢探索和掌握 These flaws are called zero-day vulnerabilities, and they are a common target of cyber criminals.等同于：These flaws are called zero-day vulnerabilities which are a common target of cyber criminals. 先行词vulnerabilities指物，主语为they，此时用主格关系代名词which，引导非限定性定语从句时候不能用that。]]></content>
      <tags>
        <tag>English,英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Study English One Day]]></title>
    <url>%2F2020%2F01%2F02%2FStudy-English-One-Day%2F</url>
    <content type="text"><![CDATA[2020年立个flat 刻意学习和练习英语 跟着《程序员的英语》学起英语来。 五个基本基本句式句式1为【主语 + 动词（vi）】，是基本句式 vi，不及物动词，不能直接跟宾语，需要一些介词跟着，例如，to，of，at等 He made toward the center station.他（He，主语） 向中央车站 走过去（toward，动词）。 句式2为【主语 + 动词 + 补语】 补语，对主语的补充说明 He will make a good programer.他（He，主语） 将要成为（make，动词） 一名优秀的程序员（programer，补语，对主语他的补充说明）。 句式3为【主语 + 动词（vt） + 宾语】句式2和句式3的区分方式是，如果一般动词可以用be动词代替，则属于句式2，否则是句式3 vt 及物动词，能够直接宾语 Make hay while the sun shines.晒（make，动词） 干草（hay，名词） 需要好太阳（sun，主语）。（寓意，看好时机干活） 句式4为【主语 + 动词 + 宾语（间接宾语） + 宾语（直接宾语）】He made me the simple dudoku app.他（He，主语） 给我（me，间接宾语） 做（made，动词）了 一个简单的数独app（直接宾语）。 句式5为【主语 + 动词 + 宾语 + 补语】，宾语和补语是可以同时出的。宾补，可以是不定式to、现在分词、过去分词等He made her happy.他（He，主语）使（made，动词）她（her，宾语）幸福（happy，补语）]]></content>
      <tags>
        <tag>English,英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String of Java]]></title>
    <url>%2F2019%2F08%2F25%2FString-of-Java%2F</url>
    <content type="text"><![CDATA[String 概括 string 名次，意思可以翻译为：线，弦，细绳；一串，一行等 再来看看String的类图，String的value是不是感觉很应景呢？一个个字符，串起来变成我们熟悉的字符串。这里有两个关键的field：value和hash。 String 三连击String变量到底存储在哪里？（JDK8)1234public class StringDemo &#123; public static void main(String[] args) &#123; String hello = "hello"; &#125; 通过命令 javap -v StringDemo.class 对编译后的文件进行编码，会看到以下内容： 1234567public class cn.hy.study.string.StringDemo minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#20 // java/lang/Object."&lt;init&gt;":()V #2 = String #16 // hello 可以看到，hello 这个字符串被存在了常量池（Constant pool）中，那么常量池又会存在哪里呢？ 通过下面代码，我们来看看jdk 1.8 的常量池是存在哪一块：1234567String hello = "hello";ArrayList list = new ArrayList();for (; ; ) &#123; String tmp = hello + new Random().nextInt(); hello = tmp; list.add(tmp.intern());&#125; jvm参数添加：-Xmx2m -XX:+PrintGCDetails 之后，运行不到一会儿，估计就会有下面的提醒了： 12341.8Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at ... 1231.7Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:2367) 1231.6Exception in thread "main" java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) 堆的内存分布： 1234567891011121314151617181920212223242526272829301.8Heap PSYoungGen total 1024K, used 17K [...) eden space 512K, 3% used [...) from space 512K, 0% used [...) to space 512K, 0% used [...) ParOldGen total 512K, used 401K [...) object space 512K, 78% used [...) Metaspace used 2728K, capacity 4486K, committed 4864K, reserved 1056768K class space used 291K, capacity 386K, committed 512K, reserved 1048576K1.7Heap PSYoungGen total 2048K, used 22K [...) eden space 1024K, 2% used [...) from space 1024K, 0% used [...) to space 1024K, 0% used [...) ParOldGen total 4096K, used 267K [...) object space 4096K, 6% used [...) PSPermGen total 21504K, used 2652K [...) object space 21504K, 12% used [...)1.6Heap par new generation total 1152K, used 41K [...) eden space 1024K, 4% used [...) from space 128K, 0% used [...) to space 128K, 0% used [...) concurrent mark-sweep generation total 5312K, used 279K [...) concurrent-mark-sweep perm gen total 83968K, used 4693K [...) 我们知道jvm的内存结构，分为，堆、栈、方法区。从上面，我可以看到jdk 1.8 中字符串常量池存在于jvm的堆内存中。综上所诉，可以看到 注：PermGen space 全程 Permanent Generation space 永久的产生的空间，也就是常说的永久代，在1.8以后已经被Meta space所代替。 String哪个方法最重要？从问题一我们可以知道，字符串是保存到常量池中，但是常量池中保存到字符串是如何快速返回字符串给调用方呢？如果让我来设计，我会将它放在哈希表中，通过合理设计hash函数，使得字符串合理分布在哈希表中，使得我们能迅速获取已经存在常量池中的字符串。下面是String的hashCode方法： 1234567891011121314/** Cache the hash code for the string */private int hash; // Default to 0public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 这里最难理解就是： 1234for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i];&#125;--&gt; s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 这里为啥是31 * h根据资料查阅，加上自己的一些理解，我觉得比较合理的解释： 31 * h == (h &lt;&lt; 5) - h，VM优化成位运算，使得计算hash code 性能更好 31 是一个不大不小的奇质数，也可以使得 hashCode 尽可能均匀分布。 除了以上，我们还可以发现一个有趣的地方 if (h == 0 &amp;&amp; value.length &gt; 0) ，这里用到了闪存散列代码（caching the hash code），无需二次计算 hash code，是一个比较典型空间换时间的应用，它之所以行之有效，其实有一个大前提就是String是final/immutable。 哈希表，搜索的平均时间复杂度为：O(1)，最坏的时间复杂度：O(n)。质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。 String哪个方法体逻辑最难懂，分享出来。个人觉得 split 方法是在String中相对比较难懂。12345678910111213141516 /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters ".$|()[&#123;^?*+\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */if (((regex.value.length == 1 &amp;&amp; ".$|()[&#123;^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; 这个if语句想判断 regex 是否为 fastpath 而不是正则表达式，否则直接跑下面的代码:1return Pattern.compile(regex).split(this, limit); 所以用这个API的时候，我们最好不要使用 &quot;.$|()[{^?*+\\&quot; 中的字符来进行分割，如果实在要用 需要通过 \\ 来转义。举个栗子：12345String s = "A,b|中,c";for (String word : s.split("\\|")) &#123; System.out.println(word);&#125; 输出结果为：12A,b中,c 分析完，感觉最困难的return Pattern.compile(regex).split(this, limit); 并没有分析到，下次如果有深入了解正则表达式的想法可以死磕一波。 参考 Java 中的 String.hashCode() 方法可能有问题？ why-does-javas-hashcode-in-string-use-31-as-a-multiplier 科普：为什么 String hashCode 方法选择数字31作为乘子 Effective Java 数据结构与算法分析 Java语言描述]]></content>
      <tags>
        <tag>Java,Java基础,hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你喜欢技术吗？]]></title>
    <url>%2F2019%2F07%2F13%2F%E4%BD%A0%E5%96%9C%E6%AC%A2%E6%8A%80%E6%9C%AF%E5%90%97%2F</url>
    <content type="text"><![CDATA[技术的本身是什么？我从维基百科找了一个差不多定义 技术可以指人类对机器、硬件或人造器皿的运用，但它也可以包含更广的架构，如系统、组织方法学和技巧。 我的成长印记那一年春节那一年春节（约2005年），我哥苦苦哀求老爸买下叔叔自己组装的电脑的情景。现在回想起来，我的技术成长的印记最初应该是从那时候开始。叔叔送我们一本厚厚的关于计算机的书，里面介绍了计算机的基本组成，一些常用的问题的处理等等。我从小不太喜欢看书，我竟然为了计算机把书啃完了。当我掌握了修电脑的技能后，村里如果谁家的电脑有问题了，就叫我去帮忙看看，但是也试过删除人家整个硬盘的资料，然后花了一个晚上慢慢找回数据。 数码产品高中那三年，抱着智能手机过来的，从最初的塞班爱好者，到Windows Mobile 手机，再到后来的安卓和iOS，都是让我如痴如醉，那时候安卓刚刚出来的时候，强行将自己的Windows mobile 手机刷成安卓系统，后来热的不行，冬天的时候刚刚可以当成暖手宝。安卓就是刷机，刷成瘾，帮雷总测试miui，到后来拿到全国第一批的小米1，然后转手卖掉，赚了几百块钱，也是美滋滋。 大学学渣高考过后，填写志愿所有的学校报都是软件工程，当时想法很单纯，就是想学习计算机软件相关的东西。暑假的时候买一本c语言相关的书籍，提前自学了。大一，经过媳妇（那时候还没有在一起哈哈）给我恶补的离散数学和高数还好没有挂科。大二，学完c++，还有数据结构等课程，现在想起来好像都还给老师了，最近也在恶补这个方面的东西。大三，基本开始Java 和安卓这些课程了。大四，基本不再上课，很多同学开始实习了，最后我也坐不住了，趁着暑假的时候，我也进去第一家公司去实习了，就这样子踏上了不归路了。 几大学最后悔的事情，就是没有参加过一次编程比赛，如果有还在读书的小伙伴，记得一定不要让自己后悔了。 从代码的搬运工，真正的搬砖从开始，工作只是为了完成上级交给的任务。很少思考，这个需求的真实内在需求。但是，慢慢会发现，工作其实不是想象中那么简单的。很多时候，需求你的理解是这样子，产品的理解是那样子，很容易出现xy问题。所以，沟通理解 十分重要，一定要准确表达自己的意思，也要力求理解别人说的，至少在百分之五十左右，不然会严重的问题。例如，做完了需求，产品说这个不是他想要的，这个就很操蛋了。可能说偏了，但是沟通好了，肯定是有助于提高我们的技术。2017年的时候，我的上级在指导我的时候，由于我的表达和理解不到位，差点吵起来了，但是坐下来，好好想一下，才知道上级的真正表达的意思。如果我们的沟通理解能力越强，技术的提升会更加快。 技术给你的成就感是什么？计算机给我的成就感，就是能帮助到别人我就很开心，当然不小心格式化了别人的硬盘我也会很不开心。软件开发，给我成就感，从最初的一次次任务的完成就很满足，到现在的方案是否为最优才会有成就感。一个产品经理跟我说，只有有价值的东西，才有可能会存在。现在，会思考自己做的东西是否有价值，如果觉得是无价值的东西，有时候会感觉成就感很低。 最后，我觉得技术，不单单是指软件开发本身，更多说的是思维的模式，只有不断思考，我们的技术才会越来越来好。 看山是山，看山不是山，看山还是山。 少吃零食，多看书，多看报，多思考，多睡觉。如果尽信书不如无书，所以每个人都需要有自己的思考能力。做人嘛，最紧要就系开心😄！！！全世界晚安！！！]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的包装类型]]></title>
    <url>%2F2019%2F04%2F03%2FJava%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概述顾名思义，包装类型就是对基本类型的封装的对象。 基本类型 包装类型 大小 默认值 boolean Boolean 1B false byte Byte 1B 0 short Short 2B 0 char Character 2B ‘\u0000’ int Integer 4B 0 long Long 8B 0L float Float 4B 0.0f double Double 8B 0.0d 包装类型为啥需要包装类型？将基本类型封装成对象，提供更多的功能，解决基础类型无法解决的问题：泛型类型参数、序列化、数据类型转换、高频区间数据缓存。例如： 泛型类型参数的问题：List&lt;int&gt; list; 这种定义是否无法通过编译的，需要将int 转成对应的包装类型 Integer ，才运行添加到集合中； 类型转换的问题：提供 Integer.valueOf(&quot;123&quot;) 将字符串转成数字的功； 高频区间数据缓存的问题：Integer.java 源码中 valueOf(int i) 的方法，提供 -128~127高频区间的数据缓存。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 包装类型和基本类型的互相转化JDk 5 以前没有自动拆装箱，可以通过下面的方式进行装箱和拆箱： 1234// 装箱Long wrapperLong = new Long(1);// 拆箱long aLong = wrapperLong.longValue(); 拥有了自动拆装箱的代码，相对会简洁一些： 1234// 自动装箱Long wrapperLong = 1L;// 自动拆箱long aLong = wrapperLong; 简单的例子，说明一下它们的区别源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 基础类型学习，如果两个数 相等，相加后返回，否则直接返回第一个参数。 * * @author wusonghui@bubi.cn * @since 1.0.0 2019-04-02 15:01 */public class PrimitiveTypeStudy &#123; public static void main(String[] args) &#123; // 自动装箱 Long wrapperLong = 1L; // 自动拆箱 long aLong = wrapperLong; add(Long.valueOf(1L), Long.valueOf(1L)); add(Long.valueOf(1L), 1L); add(1L, 1L); &#125; /** * 测试 所有数据都为 长整型 包装类型 * * @param first 长整型 包装类型 * @param second 长整型 包装类型 * @return 长整型 包装类型 */ public static Long add(Long first, Long second) &#123; if (first.equals(second)) &#123; return first + second; &#125; return first; &#125; /** * 测试 second 参数为 基本类型，其他均为 包装类型 * * @param first 长整型 包装类型 * @param second 长整型 基本类型 * @return 长整型 包装类型 */ public static long add(Long first, long second) &#123; if (first.equals(second)) &#123; return first + second; &#125; return first; &#125; /** * 测试 所有数据都为 长整型 基本类型 * * @param first 长整型 基本类型 * @param second 长整型 基本类型 * @return 长整型 包装类型 */ public static long add(long first, long second) &#123; if (first == second) &#123; return first + second; &#125; return first; &#125;&#125; 反编译回来的代码： 123456789101112131415161718192021222324252627282930313233343536373839package cn.hy.study.basictype;import java.io.PrintStream;public class PrimitiveTypeStudy&#123; public static void main(String[] args) &#123; Long wrapperLong = Long.valueOf(1L); long aLong = wrapperLong.longValue(); add(Long.valueOf(1L), Long.valueOf(1L)); add(Long.valueOf(1L), 1L); add(1L, 1L); &#125; public static Long add(Long first, Long second) &#123; if (first.equals(second)) &#123; return Long.valueOf(first.longValue() + second.longValue()); &#125; return first; &#125; public static long add(Long first, long second) &#123; if (first.equals(Long.valueOf(second))) &#123; return first.longValue() + second; &#125; return first.longValue(); &#125; public static long add(long first, long second) &#123; if (first == second) &#123; return first + second; &#125; return first; &#125;&#125; 通过javap -v -p PrimitiveTypeStudy.class 命令生成，字节码内容，为了对比的效果，我在前后加入反编译后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277Classfile /Users/jaryoung/project/demo/javabasic/out/production/classes/cn/hy/study/basictype/PrimitiveTypeStudy.class Last modified Apr 3, 2019; size 1530 bytes MD5 checksum db6d2b4373555e4e52196d58a3ba87b5 Compiled from "PrimitiveTypeStudy.java"public class cn.hy.study.basictype.PrimitiveTypeStudy minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #19.#44 // java/lang/Object."&lt;init&gt;":()V #2 = Class #45 // java/lang/Long #3 = Methodref #2.#46 // java/lang/Long."&lt;init&gt;":(J)V #4 = Methodref #2.#47 // java/lang/Long.longValue:()J #5 = Fieldref #48.#49 // java/lang/System.out:Ljava/io/PrintStream; #6 = Class #50 // java/lang/StringBuilder #7 = Methodref #6.#44 // java/lang/StringBuilder."&lt;init&gt;":()V #8 = String #51 // #9 = Methodref #6.#52 // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #10 = Methodref #6.#53 // java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; #11 = Methodref #6.#54 // java/lang/StringBuilder.toString:()Ljava/lang/String; #12 = Methodref #55.#56 // java/io/PrintStream.println:(Ljava/lang/String;)V #13 = Methodref #2.#57 // java/lang/Long.valueOf:(J)Ljava/lang/Long; #14 = Methodref #18.#58 // cn/hy/study/basictype/PrimitiveTypeStudy.add:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; #15 = Methodref #18.#59 // cn/hy/study/basictype/PrimitiveTypeStudy.add:(Ljava/lang/Long;J)J #16 = Methodref #18.#60 // cn/hy/study/basictype/PrimitiveTypeStudy.add:(JJ)J #17 = Methodref #2.#61 // java/lang/Long.equals:(Ljava/lang/Object;)Z #18 = Class #62 // cn/hy/study/basictype/PrimitiveTypeStudy #19 = Class #63 // java/lang/Object #20 = Utf8 &lt;init&gt; #21 = Utf8 ()V #22 = Utf8 Code #23 = Utf8 LineNumberTable #24 = Utf8 LocalVariableTable #25 = Utf8 this #26 = Utf8 Lcn/hy/study/basictype/PrimitiveTypeStudy; #27 = Utf8 main #28 = Utf8 ([Ljava/lang/String;)V #29 = Utf8 args #30 = Utf8 [Ljava/lang/String; #31 = Utf8 wrapperLong #32 = Utf8 Ljava/lang/Long; #33 = Utf8 aLong #34 = Utf8 J #35 = Utf8 add #36 = Utf8 (Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; #37 = Utf8 first #38 = Utf8 second #39 = Utf8 StackMapTable #40 = Utf8 (Ljava/lang/Long;J)J #41 = Utf8 (JJ)J #42 = Utf8 SourceFile #43 = Utf8 PrimitiveTypeStudy.java #44 = NameAndType #20:#21 // "&lt;init&gt;":()V #45 = Utf8 java/lang/Long #46 = NameAndType #20:#64 // "&lt;init&gt;":(J)V #47 = NameAndType #65:#66 // longValue:()J #48 = Class #67 // java/lang/System #49 = NameAndType #68:#69 // out:Ljava/io/PrintStream; #50 = Utf8 java/lang/StringBuilder #51 = Utf8 #52 = NameAndType #70:#71 // append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #53 = NameAndType #70:#72 // append:(J)Ljava/lang/StringBuilder; #54 = NameAndType #73:#74 // toString:()Ljava/lang/String; #55 = Class #75 // java/io/PrintStream #56 = NameAndType #76:#77 // println:(Ljava/lang/String;)V #57 = NameAndType #78:#79 // valueOf:(J)Ljava/lang/Long; #58 = NameAndType #35:#36 // add:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; #59 = NameAndType #35:#40 // add:(Ljava/lang/Long;J)J #60 = NameAndType #35:#41 // add:(JJ)J #61 = NameAndType #80:#81 // equals:(Ljava/lang/Object;)Z #62 = Utf8 cn/hy/study/basictype/PrimitiveTypeStudy #63 = Utf8 java/lang/Object #64 = Utf8 (J)V #65 = Utf8 longValue #66 = Utf8 ()J #67 = Utf8 java/lang/System #68 = Utf8 out #69 = Utf8 Ljava/io/PrintStream; #70 = Utf8 append #71 = Utf8 (Ljava/lang/String;)Ljava/lang/StringBuilder; #72 = Utf8 (J)Ljava/lang/StringBuilder; #73 = Utf8 toString #74 = Utf8 ()Ljava/lang/String; #75 = Utf8 java/io/PrintStream #76 = Utf8 println #77 = Utf8 (Ljava/lang/String;)V #78 = Utf8 valueOf #79 = Utf8 (J)Ljava/lang/Long; #80 = Utf8 equals #81 = Utf8 (Ljava/lang/Object;)Z&#123; public cn.hy.study.basictype.PrimitiveTypeStudy(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 14: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcn/hy/study/basictype/PrimitiveTypeStudy; /* public static void main(String[] args) &#123; Long wrapperLong = Long.valueOf(1L); long aLong = wrapperLong.longValue(); add(Long.valueOf(1L), Long.valueOf(1L)); add(Long.valueOf(1L), 1L); add(1L, 1L); &#125; */ public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=4, args_size=1 0: new #2 // class java/lang/Long 3: dup 4: lconst_1 5: invokespecial #3 // Method java/lang/Long."&lt;init&gt;":(J)V 8: astore_1 9: aload_1 10: invokevirtual #4 // Method java/lang/Long.longValue:()J 13: lstore_2 14: getstatic #5 // Field java/lang/System.out:Ljava/io/PrintStream; 17: new #6 // class java/lang/StringBuilder 20: dup 21: invokespecial #7 // Method java/lang/StringBuilder."&lt;init&gt;":()V 24: ldc #8 // String 26: invokevirtual #9 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 29: lload_2 30: invokevirtual #10 // Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; 33: invokevirtual #11 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 36: invokevirtual #12 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: lconst_1 40: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 43: lconst_1 44: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 47: invokestatic #14 // Method add:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; 50: pop 51: lconst_1 52: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 55: lconst_1 56: invokestatic #15 // Method add:(Ljava/lang/Long;J)J 59: pop2 60: lconst_1 61: lconst_1 62: invokestatic #16 // Method add:(JJ)J 65: pop2 66: return LineNumberTable: line 19: 0 line 21: 9 line 22: 14 line 23: 39 line 24: 51 line 25: 60 line 29: 66 LocalVariableTable: Start Length Slot Name Signature 0 67 0 args [Ljava/lang/String; 9 58 1 wrapperLong Ljava/lang/Long; 14 53 2 aLong J /* public static Long add(Long first, Long second) &#123; if (first.equals(second)) &#123; return Long.valueOf(first.longValue() + second.longValue()); &#125; return first; &#125; */ public static java.lang.Long add(java.lang.Long, java.lang.Long); descriptor: (Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=2, args_size=2 0: aload_0 1: aload_1 2: invokevirtual #17 // Method java/lang/Long.equals:(Ljava/lang/Object;)Z 5: ifeq 21 8: aload_0 9: invokevirtual #4 // Method java/lang/Long.longValue:()J 12: aload_1 13: invokevirtual #4 // Method java/lang/Long.longValue:()J 16: ladd 17: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 20: areturn 21: aload_0 22: areturn LineNumberTable: line 39: 0 line 40: 8 line 42: 21 LocalVariableTable: Start Length Slot Name Signature 0 23 0 first Ljava/lang/Long; 0 23 1 second Ljava/lang/Long; StackMapTable: number_of_entries = 1 frame_type = 21 /* same */ /* public static long add(Long first, long second) &#123; if (first.equals(Long.valueOf(second))) &#123; return first.longValue() + second; &#125; return first.longValue(); &#125; */ public static long add(java.lang.Long, long); descriptor: (Ljava/lang/Long;J)J flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=3, args_size=2 0: aload_0 1: lload_1 2: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 5: invokevirtual #17 // Method java/lang/Long.equals:(Ljava/lang/Object;)Z 8: ifeq 18 11: aload_0 12: invokevirtual #4 // Method java/lang/Long.longValue:()J 15: lload_1 16: ladd 17: lreturn 18: aload_0 19: invokevirtual #4 // Method java/lang/Long.longValue:()J 22: lreturn LineNumberTable: line 53: 0 line 54: 11 line 56: 18 LocalVariableTable: Start Length Slot Name Signature 0 23 0 first Ljava/lang/Long; 0 23 1 second J StackMapTable: number_of_entries = 1 frame_type = 18 /* same */ /* public static long add(long first, long second) &#123; if (first == second) &#123; return first + second; &#125; return first; &#125; */ public static long add(long, long); descriptor: (JJ)J flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=4, args_size=2 0: lload_0 1: lload_2 2: lcmp 3: ifne 10 6: lload_0 7: lload_2 8: ladd 9: lreturn 10: lload_0 11: lreturn LineNumberTable: line 68: 0 line 69: 6 line 71: 10 LocalVariableTable: Start Length Slot Name Signature 0 12 0 first J 0 12 2 second J StackMapTable: number_of_entries = 1 frame_type = 10 /* same */&#125;SourceFile: "PrimitiveTypeStudy.java" 结论除了 POJO 类属性 和 RPC 方法的返回值和参数之外，其他情况建议使用基本类型。 部分内容都是引用自： 《码出高效》https://www.baeldung.com/java-wrapper-classes]]></content>
      <tags>
        <tag>Java,Java基础,Java数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Docker（针对开发人员）]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%88%9D%E8%AF%86Docker%2F</url>
    <content type="text"><![CDATA[概括Docker 是世界领先的软件容器平台。开发人员利用 Docker 可以解决，“在我的机器上可正常工作的啊！！！”的问题 容器又是什么东西？容器是一种标准化的软件单元。容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。 图片出自：https://www.docker-cn.com/what-container 容器和虚拟机 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。 容器和虚拟机对比 容器 虚拟机 容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。 虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因 图片出自：https://www.docker-cn.com/what-container 图片出自：https://www.docker-cn.com/what-container 容器和虚拟机共用 将容器和虚拟机配合使用，为应用的部署和管理提供极大的灵活性。 图片出自：https://www.docker-cn.com/what-container 获取docker（针对Mac 用户） 建议注册一个账户 然后通过官网链接下载桌面版的Docker，官网超链接，如果想快一点可以试试看这个链接 。(默认最新稳定版) 下载完，安装好，配置一下Docker 中国官方镜像加速源 http://registry.docker-cn.com，当然你也是可以选择其他的加速源例如阿里，网易等等。配置完，记得点击Apply&amp;Restart。 打开Terminal ，输入一下命令 docker info 安装工具，到此结束了，是不是想说So easy？其实就是如此轻松，马上可以享受到Docker带来的快感吧！ 使用Docker我习惯上来先查一下，help（不想看，直接跳过哈，下面会开始讲，我目前经常使用的一些命令。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576docker helpUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default "/Users/jaryoung/.docker") -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default "/Users/jaryoung/.docker/ca.pem") --tlscert string Path to TLS certificate file (default "/Users/jaryoung/.docker/cert.pem") --tlskey string Path to TLS key file (default "/Users/jaryoung/.docker/key.pem") --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: builder Manage builds config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumesCommands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codesRun 'docker COMMAND --help' for more information on a command. docker search1234567891011docker search --helpUsage: docker search [OPTIONS] TERMSearch the Docker Hub for images，为了在Docker Hub上面搜 **资源**（你们都懂得）Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output 例如，我需要搜索一下上面有哪些mysql镜像，我们可以看到下面到信息： 123456docker search mysqlNAME（名称） DESCRIPTION（描述） STARS（多少次好评） OFFICIAL（官方） AUTOMATED（自动化）mysql MySQL is a widely used, open-source relation… 7964 [OK]mariadb MariaDB is a community-developed fork of MyS… 2665 [OK]mysql/mysql-server Optimized MySQL Server Docker images. Create… 598 [OK]... docker pull123456789docker pull --helpUsage: docker pull [OPTIONS] NAME[:TAG|@DIGEST]Pull an image or a repository from a registryOptions: -a, --all-tags Download all tagged images in the repository --disable-content-trust Skip image verification (default true) 例如，我们可以通过 docker pull mysql , 来下载最新版的mysql镜像。如果需要带上TAG，例如 docker pull mysql:5.7 docker run123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354docker run --helpUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]Run a command in a new containerOptions(删除了一部分，详细的情况，可以自己查询): --add-host list Add a custom host-to-IP mapping (host:ip) -d, --detach Run container in background and print container ID --detach-keys string Override the key sequence for detaching a container --device list Add a host device to the container --device-cgroup-rule list Add a rule to the cgroup allowed devices list --device-read-bps list Limit read rate (bytes per second) from a device (default []) --device-read-iops list Limit read rate (IO per second) from a device (default []) --device-write-bps list Limit write rate (bytes per second) to a device (default []) --device-write-iops list Limit write rate (IO per second) to a device (default []) --disable-content-trust Skip image verification (default true) --dns list Set custom DNS servers --dns-option list Set DNS options --dns-search list Set custom DNS search domains --entrypoint string Overwrite the default ENTRYPOINT of the image -e, --env list Set environment variables --env-file list Read in a file of environment variables --expose list Expose a port or a range of ports --group-add list Add additional groups to join --health-cmd string Command to run to check health --health-interval duration Time between running the check (ms|s|m|h) (default 0s) --health-retries int Consecutive failures needed to report unhealthy --health-start-period duration Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s) --health-timeout duration Maximum time to allow one check to run (ms|s|m|h) (default 0s) --help Print usage -h, --hostname string Container host name --init Run an init inside the container that forwards signals and reaps processes -p, --publish list Publish a container's port(s) to the host -P, --publish-all Publish all exposed ports to random ports --read-only Mount the container's root filesystem as read only --restart string Restart policy to apply when a container exits (default "no") --rm Automatically remove the container when it exits --runtime string Runtime to use for this container --security-opt list Security Options --shm-size bytes Size of /dev/shm --sig-proxy Proxy received signals to the process (default true) --stop-signal string Signal to stop a container (default "SIGTERM") --stop-timeout int Timeout (in seconds) to stop a container --storage-opt list Storage driver options for the container --sysctl map Sysctl options (default map[]) --tmpfs list Mount a tmpfs directory -t, --tty Allocate a pseudo-TTY --ulimit ulimit Ulimit options (default []) ... -v, --volume list Bind mount a volume --volume-driver string Optional volume driver for the container --volumes-from list Mount volumes from the specified container(s) -w, --workdir string Working directory inside the container Mysql1docker run -p 3306:3306 --name mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6.43 -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。 -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。 -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。 -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。 -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 Redis1docker run -p 6379:6379 -v $PWD/data:/data --name redis -d redis redis-server --appendonly yes 命令说明： -p 6379:6379 : 将容器的6379端口映射到主机的6379端口 -v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data redis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 Nginx首先，我需要创建一下，文件夹,用于主宿机之间做映射使用。 1mkdir -p &#123;conf.d,html,logs&#125; 1docker run -p 80:80 -p 84:84 -p 82:82 --name nginx -v $PWD/www:/www -v $PWD/html:/usr/share/nginx/html -v $PWD/logs:/www/logs -v $PWD/conf.d:/etc/nginx/conf.d -d nginx 命令说明： -p 80:80：主机80到容器80，-p 84:84，同理（主机 -&gt; 宿机） –name mynginx：将容器命名为nginx -v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www -v $PWD/conf/conf.d:/etc/nginx/conf.d：将主机中当前目录下的conf.d挂载到容器的/etc/nginx/conf.d 不能挂载文件，只能挂载文件夹 注意如果提醒你，是否不应该将一个文件夹挂载到文件下面，我需要自己手动创建一个nginx.conf配置文件，并放置到主机的映射配置文件夹中（$PWD/conf），重新执行即可。如果出现了没有访问你配置的静态资源，很可能是访问到默认的配置（conf.d/default.conf）,可以选择删除它，也可以选择覆盖/etc/nginx/nginx.conf，但是前提需要备份原来的nginx.conf或者在原nginx.conf上做修改会更加适合。 -v $PWD/html:/usr/share/nginx/html，讲主机中当前的目录下的文件夹挂载到容器中 这里映射不正确，很有可能导致访问403 拒绝访问的情况，如果你的html不是资源访问的跟路径，请配置正确的根路径，例如，资源是放在html/hello的文件中，需要配置到$PWD/html/hello，而不是$PWD/html。 -v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs docker ps123456789101112131415docker ps --helpUsage: docker ps [OPTIONS]List containersOptions: -a, --all Show all containers (default shows just running) -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template -n, --last int Show n last created containers (includes all states) (default -1) -l, --latest Show the latest created container (includes all states) --no-trunc Don't truncate output -q, --quiet Only display numeric IDs -s, --size Display total file sizes 例如，我们可以运行 docker ps -a ,查询一下我们容器中启动的镜像的情况： 1234CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4b9f565ae5ad nginx "nginx -g 'daemon of…" 8 hours ago Up 4 minutes 0.0.0.0:84-&gt;80/tcp nginx46519e512d58 redis "docker-entrypoint.s…" 10 hours ago Up 5 minutes 0.0.0.0:6379-&gt;6379/tcp redis293c9831f58a mysql:5.6.43 "docker-entrypoint.s…" 10 hours ago Up 4 minutes 0.0.0.0:3306-&gt;3306/tcp mysql 命令说明： -a Show all containers (default shows just running)，会显示所有存在的，默认是之后显示当前容器启动的镜像。 docker stop12345678docker stop --helpUsage: docker stop [OPTIONS] CONTAINER [CONTAINER...]Stop one or more running containersOptions: -t, --time int Seconds to wait for stop before killing it (default 10) docker start12345678910docker start --helpUsage: docker start [OPTIONS] CONTAINER [CONTAINER...]Start one or more stopped containers，可以启动一个或者多个容器Options: -a, --attach Attach STDOUT/STDERR and forward signals --detach-keys string Override the key sequence for detaching a container -i, --interactive Attach container's STDIN 例如，我们可以通过 docker start nginx mysql ，同时启动两个容器 docker exec123456789101112131415docker exec --helpUsage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...]Run a command in a running containerOptions: -d, --detach Detached mode: run command in the background --detach-keys string Override the key sequence for detaching a container -e, --env list Set environment variables -i, --interactive Keep STDIN open even if not attached --privileged Give extended privileges to the command -t, --tty Allocate a pseudo-TTY -u, --user string Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) -w, --workdir string Working directory inside the container 例如，我们可以通过命令快速进入到redis-cli，docker exec -it redis redis-cli，输入exit 就可以推出 很多内容都是引用自： http://www.runoob.com/docker/docker-tutorial.htmlhttps://www.docker-cn.com]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
