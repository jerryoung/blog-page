<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《Netty in Action》 读后感]]></title>
    <url>%2F2020%2F02%2F07%2FNetty-in-Action-After-Reading%2F</url>
    <content type="text"><![CDATA[开编我想说 刻意练习，本着课本的例子，照着我也写一遍的原则进行练习。 基础知识真的太重要，很多基础知识是会影响我们阅读书的效果，甚至可能会误解书本的原意。就拿着当前阅读的书来说起，如果我们不知道计算机操作系统基础，不知Java网络编程基础，不知网络协议等，那么我们看书可能会举步维艰。所以，在看本书之前，我尝试查阅一些相关资料，以补充能够更好吸收书本知识。 本文章，就是书本很多地方的内容，并未能深刻理解，一本书的内容也不可能全部呈现。例如，零拷贝，各种网络协议的理解，例如tcp，udp协议等。很多基础内容，都感觉相对薄弱，所以日后需要加强基础的部分。 看完，你可能会有以下收获： Netty核心组件、重新认识字节、关于Netty单元测试、编码器和解码器、WebSocket简单的聊天室 阅读前的预习，大有裨益 同步和异步的概念 同步，是一个可靠的有序操作，例如，有顺序执行操作A-&gt;操作B，如果操作A没有完成返回，操作B需要排队等候；反之，异步则相反无需等待，通常可以依靠回调或者事件的方式来进行操作的次序的问题。 堵塞和非堵塞 在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；而非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理。 查询常见的I/O模型：I/O堵塞;I/O非堵塞;I/O复用；信号驱动I/O；异步I/O 用户空间和系统空间 现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。摘抄自这里 Linux 操作系统中select、poll、epoll详细内容可以查看 High-Performance I/O Design Patterns详细内容可以看 概述 Netty is an asynchronous event-driven network application frameworkfor rapid development of maintainable high performance protocol servers &amp; clients. 从上面我抽取了三个关键词，asynchronous、event-driven、high performance。带着三个关键信息，看能够从书中摄取到三个核心的内容。 核心内容核心组件Channel Channel，是出入站数据的载体，或者是网络中Socket抽象代表。目的：Channel为了降低直接使用Java中Socket API的复杂度。 Channel的生命周期：register-&gt;active-&gt;inactive-&gt;unregistred EventLoop 用于处理连接的生命周期的中发生的事件 Channel、EventLoop和EventLoopGroup的关系图 图中可以看到EventLoopGroup其实就具有多个EventLoop的组，EventLoop会在Channel的整个生命周期处理I/O事件。三者关系如下： 一个EventLoopGroup包含一个或者多个EventLoop 一个EventLoop一个生命周期中，只和一个线程绑定 EventLoop所有I/O处理事件，将有专用的线程处理 一个Channel生命周期，只会注册到一个EventLoop上 一个EventLoop可以会分配多个Channel 得益于EventLoop是一个固定的线程处理，给定的Channel上的I/O的处理将会在同一个线程处理，避免了不必要的线程切换上下文的开销； 下面来深入了解一下，EventLoop：先通过类图去纵览 java.util.concurrentAbstractExecutorService主要是实现了ExecutorService接口，ScheduledExecutorService则是继承了ExecutorService； io.netty.utilconcurrentAbstractEventExecutor，继承了AbstractExecutorService类，并且实现EventExecutor接口， io.netty.channelEventLoop，继承了OrderedEventExecutor, EventLoopGroup，只有一个：EventLoopGroup parent()方法。SingleThreadEventLoop，继承SingleThreadEventExecutor，并且实现EventLoop接口；重头戏来了，NioEventLoop，是继承了SingleThreadEventLoop，正如上面所说的：一个EventLoop一个生命周期中，只和一个线程绑定 EventLoop的执行逻辑： ChannelPipeline pipeline，意译为管道，ChannelPipeline，一看到这个名字，我们能够猜到它的作用就是类似管道的作用。目的：为了提供ChannelHandler链式容器（ChannelHandler在下一节介绍） 本节，需要了解pipeline它的头部和尾部的概念，入站从头部第一个ChannelHandler先入，出站的时候从尾端端第一个ChannelHandler先开始流出。 顺便提一下，Channel一旦分配为ChannelPipeline后，是永久性操作，不能被修改。通过 DefaultChannelPipeline 和 AbstractChannel 源代码分析，也能得到上面的结论： 12345AbstractChannel protected AbstractChannel(Channel parent) &#123; ... pipeline = newChannelPipeline();// 新建分配一个ChannelPipeline &#125; 12345DefaultChannelPipeline protected DefaultChannelPipeline(Channel channel) &#123; ... this.channel = ObjectUtil.checkNotNull(channel, "channel"); &#125; 最后，上面的设计使得，我们 变动（增删改） ChannelPipeline上的Handler也是相当方便的。 ChannelHandler ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler生命周期：added-&gt;removed (excption)通过ChannelHandler再来看出入站的概念：入站，就是数据流要进行我们的服务前置的业务处理。出站，就是我们需要返回数据流时候的后置业务处理。当然我们还是需要谨记，上一节的pipeline的头部和尾端的概念，不然会容易出或者入站的handler出现位置不对的情况。 ChannelInboundHandler 入站处理器接口，处理入站数据和状态变化列出我在练习中常用的方法： 类 型 描 述 channelRegistered 当Channel已经注册到它的EventLoop并且能够处理I/O时被调用 channelUnregistered 当Channel从它的EventLoop注销并且无法处理任何I/O时被调用 channelActive 当Channel处于活动状态时被调用；Channel已经连接/绑定并且已经就绪 channelInactive 当Channel离开活动状态并且不再连接它的远程节点时被调用 channelReadComplete 当Channel上的一个读操作完成时被调用 channelRead 当从Channel读取数据时被调用 userEventTriggered 当ChannelnboundHandler.fireUserEventTriggered()方法被调用时被调用，因为一个POJO被传经了ChannelPipeline 我们可以通过继承 ChannelInboundHandlerAdapter 来编写自己的入站处理器。常用的是：SimpleChannelInboundHandler，因为它给我优化了一些常用的操作，例如，资源的自动释放等 异常处理：exceptionCaught，这个方法在 ChannelInboundHandlerAdapter 已经标记被弃用， ChannelOutboundHandler 出站处理器接口，处理出站的所有数据，并且能够拦截所有的操作。列出我在练习中常用的方法： 类 型 描 述 bind(ChannelHandlerContext,SocketAddress,ChannelPromise) 当请求将Channel绑定到本地地址时被调用 connect(ChannelHandlerContext,SocketAddress,SocketAddress,ChannelPromise)当 请求将Channel连接到远程节点时被调用 disconnect(ChannelHandlerContext,ChannelPromise) 当请求将Channel从远程节点断开时被调用 close(ChannelHandlerContext,ChannelPromise) 当请求关闭Channel时被调用 deregister(ChannelHandlerContext,ChannelPromise) 当请求将Channel从它的EventLoop注销时被调用 read(ChannelHandlerContext) 当请求从Channel读取更多的数据时被调用 flush(ChannelHandlerContext) 当请求通过Channel将入队数据冲刷到远程节点时被调用 write(ChannelHandlerContext,Object,ChannelPromise) 当请求通过Channel将数据写到远程节点时被调用 异常处理：两种方式： 在出站操作都会返回ChannelFuture，进行添加监听事件 在ChannelOutboundHandler的入参都会带有ChannelPromis，进行添加监听事件方式2更加常用，因为相对方式1相关更加简单有效。 ChannelHandlerContext紧接上面，我来看一下Channel、ChannelPipeline、ChannelHandler和ChannelHandlerContext之间的关系：当ChannelHandler添加到ChannelPipeline到时候，ChannelHandlerContext将会被创建。 ChannelHandler高级用法：我们可以在使用ChannelHandler可以缓存ChannelHanlderContext，然后去完成一些复杂的操作。但是这里是有一个前提，就是当前ChannelHandler应该是被@Sharable注释，因为一个ChannelHandler可能属于多个ChannelPipeline。在使用@Sharable之前，最好确保当前ChannelHandler是线程安全。 ChannelFuture Netty提供了ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener，以便在某个操作完成时（无论是否成功）得到通知。 Bootstrap 引导客户端 和 无连接协议引导流程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public final class EchoClient &#123; static final boolean SSL = System.getProperty("ssl") != null; static final String HOST = System.getProperty("host", "127.0.0.1"); static final int PORT = Integer.parseInt(System.getProperty("port", "8023")); public static void main(String[] args) throws Exception &#123; // Configure SSL.git final SslContext sslCtx; if (SSL) &#123; sslCtx = SslContextBuilder.forClient() .trustManager(InsecureTrustManagerFactory.INSTANCE).build(); &#125; else &#123; sslCtx = null; &#125; // Configure the client. EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT)); &#125; p.addLast( new CustomSimpleChannelInboundHandler()) ; &#125; &#125;); // 在connect方法调用后，Bootstrap类将会创建一个新的Channel ChannelFuture f = b.connect(HOST, PORT).sync(); // Wait until the connection is closed. f.channel().closeFuture().sync(); &#125; finally &#123; // Shut down the event loop to terminate all threads. group.shutdownGracefully(); &#125; &#125;&#125; 引导服务器 引导流程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public final class EchoServer &#123; static final boolean SSL = System.getProperty("ssl") != null; static final int PORT = Integer.parseInt(System.getProperty("port", "8007")); public static final String SECOND_HANDLER_NAME = "second"; public static void main(String[] args) throws Exception &#123; // Configure SSL. final SslContext sslCtx; if (SSL) &#123; SelfSignedCertificate ssc = new SelfSignedCertificate(); sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(); &#125; else &#123; sslCtx = null; &#125; // Configure the server. EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(2); final EchoServerHandler serverHandler = new EchoServerHandler(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline p = ch.pipeline(); if (sslCtx != null) &#123; p.addLast(sslCtx.newHandler(ch.alloc())); p.addLast(serverHandler); &#125; &#125;); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync(); &#125; finally &#123; // Shut down all event loops to terminate all threads. bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 引导DatagramChannelNetty提供了各种DatagramChannel的实现，它唯一的区别就是不能使用connect方法，只能调用bind方法。 如何优雅关闭客户端和服务端 我主要需要关闭我们创建EventLoopGroup，我们可以通过123456789```java @Override public Future&lt;?&gt; shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) &#123; for (EventExecutor l: children) &#123; l.shutdownGracefully(quietPeriod, timeout, unit); &#125; return terminationFuture(); &#125; 重新认识字节 The byte is a unit of digital information that most commonly consists of eight bits. Historically, the byte was the number of bits used to encode a single character of text in a computer and for this reason it is the smallest addressable unit of memory in many computer architectures记住：8 bit = 1 byte 为啥说重新认识了字节，因为自己在学习ByteBuf的时候犯了一些低级的错误（单元测试将呈现我的低级错误），反应出来自己的基础还是不够牢固。下面这通过练习的例子，来认识一下Netty强大的字节容器：ByteBuff ByteBuff，实现原理有两个索引指针，一个用于读取（readerIndex），一个用于写入（writerIndex）。 下面的例子详细说，不同ByteBuff的使用模式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class ByteBuffExample &#123; public static final String HI_BYTE_BUFF = "Hi! ByteBuff."; private static final ByteBuf heapBuff = Unpooled.copiedBuffer(HI_BYTE_BUFF, CharsetUtil.UTF_8); public static final Charset UTF_8 = CharsetUtil.UTF_8; public static void main(String[] args) &#123; // 堆缓冲区 System.out.println("==================heap buff=================="); heapByteBuff(); System.out.println("==================direct buff=================="); directByteBuff(); System.out.println("==================composite buff=================="); compositeByteBuff(); System.out.println("==================read and write=================="); readAndWrite(); System.out.println("==================ByteBufHolder=================="); byteBuffHolder(); &#125; /** * 存储在 JVM 堆空间中，这种模式被成为支撑数据（backing array） */ public static void heapByteBuff() &#123; if (heapBuff.hasArray()) &#123; byte[] array = heapBuff.array(); int offset = heapBuff.arrayOffset() + heapBuff.readerIndex(); int length = heapBuff.readableBytes(); byte[] target = new byte[length]; System.arraycopy(array, offset, target, 0, length); System.out.println(new String(target)); &#125; &#125; /** * 直接缓冲区是另外一种ByteBuf模式。 * 我们期望用于对象创建的内存分配永远都来自于堆中， * 但这并不是必须的——NIO在JDK1.4中引入的ByteBuffer类允许JVM实现通过本地调用来分配内存。 * 这主要是为了避免在每次调用本地I/O操作之前（或者之后） * 将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。 * * 它的缺点主要： * 1. 分配和释放表昂贵 * 2. 如果在处理预留代码的时候，可能不得不又复制一遍。 * * 建议：如果在知道数据将被作为数据来访问的时候，我们更加推荐使用 堆内存 。 * */ private static void directByteBuff() &#123; ByteBuf directBuffer = Unpooled.directBuffer().writeBytes(heapBuff); // 检查buf是否有数组，如果不是，则说明一个直接堆缓冲区 if (!directBuffer.hasArray()) &#123; int readerIndex = directBuffer.readerIndex(); int length = directBuffer.readableBytes(); byte[] array = new byte[length]; directBuffer.getBytes(readerIndex, array); System.out.println(new String(array)); &#125; &#125; /** * 复合缓冲区，它提供一种聚合模式给我们使用。例如我需要组合一个协议， * 我们需要一部分装配头部信息，一部分装配主体信息。 */ private static void compositeByteBuff() &#123; CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer(); ByteBuf headBuf = Unpooled.copiedBuffer("Hi! ", CharsetUtil.UTF_8); ByteBuf bodyBuf = Unpooled.copiedBuffer("ByteBuff.", CharsetUtil.UTF_8); compositeByteBuf.addComponents(headBuf, bodyBuf); System.out.println("compositeByteBuf.removeComponent(0) before:"); for (ByteBuf byteBuf : compositeByteBuf) &#123; System.out.println(byteBuf.toString(CharsetUtil.UTF_8)); &#125; System.out.println("compositeByteBuf.removeComponent(0) after:"); compositeByteBuf.removeComponent(0); for (ByteBuf byteBuf : compositeByteBuf) &#123; System.out.println(byteBuf.toString(CharsetUtil.UTF_8)); &#125; &#125; /** * 主要是一些字节操作API的使用。 */ private static void readAndWrite() &#123; ByteBuf byteBuf = Unpooled.copiedBuffer(HI_BYTE_BUFF, CharsetUtil.UTF_8); System.out.println(byteBuf.toString(CharsetUtil.UTF_8)); // slice，分片，但是不会修改索引信息 ByteBuf slice = byteBuf.slice(0, 3); // 拷贝操作，不影响原对象 ByteBuf copy = byteBuf.copy(0, 3); assert !ByteBufUtil.equals(slice, copy); System.out.println(slice.toString(CharsetUtil.UTF_8)); byteBuf.setByte(0, ((byte) 'J')); copy.setByte(0, ((byte) 'W')); assert byteBuf.getByte(0) == slice.getByte(0); assert copy.getByte(0) != byteBuf.getByte(0); System.out.println(((char) byteBuf.getByte(0))); int readerIndex = byteBuf.readerIndex(); int writerIndex = byteBuf.writerIndex(); byteBuf.setByte(1, ((byte) 'B')); System.out.println(((char) byteBuf.getByte(1))); assert readerIndex == byteBuf.readerIndex(); assert writerIndex == byteBuf.writerIndex(); // 写一个字节，将会影响writerIndex索引。 byteBuf.writeByte(((byte) '?')); assert readerIndex == byteBuf.readerIndex(); assert writerIndex != byteBuf.writerIndex(); &#125; private static void byteBuffHolder() &#123; ByteBufHolder byteBufHolder = new DefaultByteBufHolder(Unpooled.copiedBuffer(HI_BYTE_BUFF, UTF_8)); ByteBuf content = byteBufHolder.copy().content(); content.setByte(0, ((byte) 'W')); System.out.println("source: " + ((char) heapBuff.getByte(0))); System.out.println("new: " + ((char) content.getByte(0))); &#125;&#125; 解码器和编码器解码器总体来说，我们有两种需求： 字节解码成消息，常用抽象类：ByteToMessageDecoder extends ChannelInboundHandlerAdapter 消息A解码成消息B，常用抽象类：MessageToMessageDecoder extends ChannelInboundHandlerAdapter它们都是继承 ChannelInboundHandlerAdapter，又是熟悉的味道，这个又是得益Netty统一的设计。流程图如下： 编码器总体来说，我们有两种需求： 消息编码成消息，常用抽象类：MessageToByteEncoder extends ChannelOutboundHandlerAdapter 消息B编码成消息A，常用抽象类：MessageToMessageEncoder extends ChannelOutboundHandlerAdapter它们都是继承了ChannelOutboundHandlerAdapter。流程图如下： 抽象的编解码类很多时候，编解码是一对，我们就想着为啥不能直接设置成一个类？Netty给我们，预设Codec。 字节编解码成消息，ByteToMessageCodec extend ChannelDuplexHandler 消息编解码成消息，MessageToMessageCodec extend ChannelDuplexHandlerChannelDuplexHandler extends ChannelInboundHandlerAdapter implements ChannelOutboundHandler HttpObjectAggregator 源码分析12HttpObjectAggregator extends MessageAggregator&lt;HttpObject, HttpMessage, HttpContent, FullHttpMessage&gt; 核心逻辑其实是在 MessageAggregator 中 decode 方法中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130@Override protected void decode(final ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out) throws Exception &#123; assert aggregating; // HttpObjectAggregator.isStartMessage: // return msg instanceof HttpMessage; if (isStartMessage(msg)) &#123; handlingOversizedMessage = false; if (currentMessage != null) &#123; currentMessage.release(); currentMessage = null; throw new MessageAggregationException(); &#125; @SuppressWarnings("unchecked") S m = (S) msg; // Send the continue response if necessary (e.g. 'Expect: 100-continue' header) // Check before content length. Failing an expectation may result in a different response being sent. Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline()); if (continueResponse != null) &#123; // Cache the write listener for reuse. // 缓存起来监听器方便重用，监听器作用：如果调用不成功，则调用fireExceptionCaught方法，抛出异常 ChannelFutureListener listener = continueResponseWriteListener; if (listener == null) &#123; continueResponseWriteListener = listener = new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) throws Exception &#123; if (!future.isSuccess()) &#123; ctx.fireExceptionCaught(future.cause()); &#125; &#125; &#125;; &#125; // Make sure to call this before writing, otherwise reference counts may be invalid. boolean closeAfterWrite = closeAfterContinueResponse(continueResponse); handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse); final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener); if (closeAfterWrite) &#123; future.addListener(ChannelFutureListener.CLOSE); return; &#125; if (handlingOversizedMessage) &#123; return; &#125; &#125; else if (isContentLengthInvalid(m, maxContentLength)) &#123; // if content length is set, preemptively close if it's too large invokeHandleOversizedMessage(ctx, m); return; &#125; if (m instanceof DecoderResultProvider &amp;&amp; !((DecoderResultProvider) m).decoderResult().isSuccess()) &#123; O aggregated; if (m instanceof ByteBufHolder) &#123; // retain方法：将引用增加+1（Netty中，如果引用值为0，则会被回收），以防止被回收 // 开始聚合操作由子类实现对应的操作 aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain()); &#125; else &#123; aggregated = beginAggregation(m, EMPTY_BUFFER); &#125; // 完成聚合操作，finishAggregation0 中调用了 finishAggregation,其中finishAggregation由子类实现。 // HttpObjectAggregator中实现了，增加了rfc2616 14.13 Content-Length 判断，如果没有响应体头部那样设置 'Content-Length'，则根据 aggregated.content().readableBytes() 设置一个值 finishAggregation0(aggregated); out.add(aggregated); return; &#125; // A streamed message - initialize the cumulative buffer, and wait for incoming chunks. CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents); if (m instanceof ByteBufHolder) &#123; appendPartialContent(content, ((ByteBufHolder) m).content()); &#125; currentMessage = beginAggregation(m, content); &#125; else if (isContentMessage(msg)) &#123; if (currentMessage == null) &#123; // it is possible that a TooLongFrameException was already thrown but we can still discard data // until the begging of the next request/response. return; &#125; // Merge the received chunk into the content of the current message. CompositeByteBuf content = (CompositeByteBuf) currentMessage.content(); @SuppressWarnings("unchecked") final C m = (C) msg; // Handle oversized message. if (content.readableBytes() &gt; maxContentLength - m.content().readableBytes()) &#123; // By convention, full message type extends first message type. @SuppressWarnings("unchecked") S s = (S) currentMessage; invokeHandleOversizedMessage(ctx, s); return; &#125; // Append the content of the chunk. appendPartialContent(content, m.content()); // Give the subtypes a chance to merge additional information such as trailing headers. aggregate(currentMessage, m); final boolean last; // 主要判断 是否为 最后的消息了，如果是最后的消息，将进行添加输出列表out中 if (m instanceof DecoderResultProvider) &#123; DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult(); if (!decoderResult.isSuccess()) &#123; if (currentMessage instanceof DecoderResultProvider) &#123; ((DecoderResultProvider) currentMessage).setDecoderResult( DecoderResult.failure(decoderResult.cause())); &#125; last = true; &#125; else &#123; last = isLastContentMessage(m); &#125; &#125; else &#123; last = isLastContentMessage(m); &#125; if (last) &#123; finishAggregation0(currentMessage); // All done out.add(currentMessage); currentMessage = null; &#125; &#125; else &#123; throw new MessageAggregationException(); &#125; &#125; 不可被忽略的单元测试1234567891011121314151617181920/** * AbsIntegerEncoder 测试类 * * @author wusonghui@bubi.cn * @date 2020-02-02 21:26 * @since 1.0.0 */public class AbsIntegerEncoder extends MessageToMessageEncoder&lt;ByteBuf&gt; &#123; @Override protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception &#123; // 这里就是我犯下的低级错误，当时没有想明白，为啥是4呢？ // 如果我们知道int是占4个字节，就很容易理解了。 // 也是从这里，让我反思。 while (msg.readableBytes() &gt;= 4) &#123; int value = Math.abs(msg.readInt()); out.add(value); &#125; &#125;&#125; 1234567891011121314151617public class AbsIntegerEncoderTest &#123; @Test public void testAbsIntegerEncoder() &#123; ByteBuf byteBuf = Unpooled.buffer(); for (int i = 0; i &lt; 10; i++) &#123; byteBuf.writeInt(i * -1); &#125; EmbeddedChannel channel = new EmbeddedChannel(new AbsIntegerEncoder()); Assert.assertTrue(channel.writeOutbound(byteBuf)); Assert.assertTrue(channel.finish()); for (int i = 0; i &lt; 10; i++) &#123; Assert.assertEquals(i, ((int) channel.readOutbound())); &#125; Assert.assertNull(channel.readOutbound()); &#125;&#125; 12345678910111213141516171819202122232425/** * 自定义待测试待 解码器 * * @author wusonghui@bubi.cn * @date 2020-02-02 20:56 * @since 1.0.0 */public class FixedLengthFrameDecoder extends ByteToMessageDecoder &#123; private final int frameLength; public FixedLengthFrameDecoder(int frameLength) &#123; if (frameLength &lt;= 0) &#123; throw new IllegalArgumentException("frameLength must be a positive integer: " + frameLength); &#125; this.frameLength = frameLength; &#125; @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; while (in.readableBytes() &gt;= frameLength) &#123; ByteBuf buf = in.readBytes(frameLength); out.add(buf); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class FrameChunkDecoderTest &#123; @Test public void testFrameChunkDecoderException() &#123; ByteBuf byteBuf = Unpooled.buffer(); for (int i = 0; i &lt; 10; i++) &#123; byteBuf.writeByte(i); &#125; ByteBuf input = byteBuf.duplicate(); EmbeddedChannel channel = new EmbeddedChannel(new FrameChunkDecoder(3)); Assert.assertTrue(channel.writeInbound(input.readBytes(2))); try &#123; channel.writeInbound(input.readBytes(4)); Assert.fail(); &#125; catch (Exception e) &#123; Assert.assertTrue(e instanceof TooLongFrameException); &#125; Assert.assertTrue(channel.writeInbound(input.readBytes(3))); Assert.assertTrue(channel.finish()); ByteBuf read = channel.readInbound(); Assert.assertEquals(byteBuf.readSlice(2), read); read.release(); read = channel.readInbound(); Assert.assertEquals(byteBuf.skipBytes(4).readSlice(3), read); read.release(); Assert.assertNull(channel.readInbound()); byteBuf.release(); &#125;&#125; 网络协议使用WebSocket WebSocket ，WebSocket协议是完全重新设计的协议，旨在为Web上的双向数据传输问题提供一个切实可行的解决方案，使得客户端和服务器之间可以在任意时刻传输消息，因此，这也就要求它们异步地处理消息回执。 使用WebSocket实现一个简单的聊天室，总体架构图如下：服务器的流程图如下： 大概代码结构如下： 12345678910111213141516src├─main ├─java ├─handler ├─HttpRequestHandler ├─TextWebSocketFrameHandler ├─initializer ├─ChatServerInitializer ├─SecureChatServerInitializer ├─server ├─ChatServer ├─SecureChatServer ├─resource ├─index.html├─test├─pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import io.netty.channel.*;import io.netty.handler.codec.http.*;import io.netty.handler.ssl.SslHandler;import io.netty.handler.stream.ChunkedNioFile;import java.io.File;import java.io.FileNotFoundException;import java.io.RandomAccessFile;import java.net.URISyntaxException;import java.net.URL;/** * HttpRequestHandler * * @author wusonghui@bubi.cn * @date 2020-02-05 15:25 * @since 1.0.0 */public class HttpRequestHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; &#123; private final String wsUri; private static File INDEX; static &#123; URL location = HttpRequestHandler.class.getProtectionDomain().getCodeSource().getLocation(); String path; try &#123; path = location.toURI() + "index.html"; path = !path.contains("file:") ? path : path.substring(5); INDEX = new File(path); if (!INDEX.exists()) &#123; throw new FileNotFoundException("path :" + path + " not found"); &#125; &#125; catch (URISyntaxException | FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public HttpRequestHandler(String wsUri) &#123; this.wsUri = wsUri; &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) throws Exception &#123; if (wsUri.equalsIgnoreCase(request.uri())) &#123; ctx.fireChannelRead(request.retain()); &#125; else &#123; if (HttpUtil.is100ContinueExpected(request)) &#123; send100Continue(ctx); &#125; RandomAccessFile file = new RandomAccessFile(INDEX, "r"); HttpResponse response = new DefaultHttpResponse(request.protocolVersion(), HttpResponseStatus.OK); response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/html; charset=UTF-8"); boolean keepAlive = HttpUtil.isKeepAlive(request); if (keepAlive) &#123; response.headers().set(HttpHeaderNames.CONTENT_LENGTH, file.length()); response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE); &#125; ctx.write(response); if (ctx.pipeline().get(SslHandler.class) == null) &#123; ctx.write(new DefaultFileRegion(file.getChannel(), 0, file.length())); &#125; else &#123; ctx.write(new ChunkedNioFile(file.getChannel())); &#125; ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT); if (!keepAlive) &#123; future.addListener(ChannelFutureListener.CLOSE); &#125; &#125; &#125; private static void send100Continue(ChannelHandlerContext ctx) &#123; FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE); ctx.writeAndFlush(response); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.channel.group.ChannelGroup;import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;/** * TextWebSocketFrameHandler * * @author wusonghui@bubi.cn * @date 2020-02-05 15:58 * @since 1.0.0 */public class TextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123; private final ChannelGroup group; public TextWebSocketFrameHandler(ChannelGroup group) &#123; this.group = group; &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if (evt instanceof WebSocketServerProtocolHandler.HandshakeComplete) &#123; ctx.pipeline().remove(HttpRequestHandler.class); group.writeAndFlush(new TextWebSocketFrame("Client " + ctx.channel() + " joined")); group.add(ctx.channel()); &#125; else &#123; super.userEventTriggered(ctx, evt); &#125; &#125; @Override protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception &#123; group.writeAndFlush(msg.retain()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940import io.netty.channel.Channel;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.group.ChannelGroup;import io.netty.example.ws.handler.HttpRequestHandler;import io.netty.example.ws.handler.TextWebSocketFrameHandler;import io.netty.handler.codec.http.HttpObjectAggregator;import io.netty.handler.codec.http.HttpServerCodec;import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.stream.ChunkedWriteHandler;/** * ChatServerInitializer * * @author wusonghui@bubi.cn * @date 2020-02-05 16:08 * @since 1.0.0 */public class ChatServerInitializer extends ChannelInitializer&lt;Channel&gt; &#123; private final ChannelGroup group; public ChatServerInitializer(ChannelGroup group) &#123; this.group = group; &#125; @Override protected void initChannel(Channel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new HttpServerCodec()) .addLast(new ChunkedWriteHandler()) .addLast(new HttpObjectAggregator(64 * 1024)) .addLast(new HttpRequestHandler("/ws")) .addLast(new WebSocketServerProtocolHandler("/ws")) .addLast(new TextWebSocketFrameHandler(group)) .addLast(new LoggingHandler(LogLevel.INFO)) ; &#125;&#125; 123456789101112131415161718192021222324252627282930import io.netty.channel.Channel;import io.netty.channel.group.ChannelGroup;import io.netty.handler.ssl.SslContext;import io.netty.handler.ssl.SslHandler;import javax.net.ssl.SSLEngine;/** * SecureChatServerInitializer * * @author wusonghui@bubi.cn * @date 2020-02-05 21:38 * @since 1.0.0 */public class SecureChatServerInitializer extends ChatServerInitializer &#123; private final SslContext sslContext; public SecureChatServerInitializer(ChannelGroup channelGroup, SslContext sslContext) &#123; super(channelGroup); this.sslContext = sslContext; &#125; @Override protected void initChannel(Channel ch) throws Exception &#123; super.initChannel(ch); SSLEngine engine = sslContext.newHandler(ch.alloc()).engine(); engine.setUseClientMode(false); ch.pipeline().addFirst(new SslHandler(engine)); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.group.ChannelGroup;import io.netty.channel.group.DefaultChannelGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.example.ws.initializer.ChatServerInitializer;import io.netty.util.concurrent.ImmediateEventExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.net.InetSocketAddress;import java.util.Objects;/** * ChatServer * * @author wusonghui@bubi.cn * @date 2020-02-05 16:29 * @since 1.0.0 */public class ChatServer &#123; private final ChannelGroup channelGroup = new DefaultChannelGroup(ImmediateEventExecutor.INSTANCE); private final EventLoopGroup bossGroup = new NioEventLoopGroup(1); private final EventLoopGroup workGroup = new NioEventLoopGroup(2); private Channel channel; protected final static String SERVER_PORT = System.getProperty("port", "9999"); private final static Logger logger = LoggerFactory.getLogger(ChatServer.class); protected ChannelFuture start() &#123; int port = Integer.parseInt(SERVER_PORT); ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workGroup) .channel(NioServerSocketChannel.class) .childHandler(createInitializer(channelGroup)); ChannelFuture future = serverBootstrap.bind(new InetSocketAddress(port)); future.syncUninterruptibly(); channel = future.channel(); Runtime.getRuntime().addShutdownHook(new Thread(this::destroy)); Objects.requireNonNull(future).channel().closeFuture().syncUninterruptibly(); if (future.isSuccess()) &#123; logger.info("Chat Server start, port: &#123;&#125;", port); &#125; else &#123; logger.info("Chat Server start failed, port: &#123;&#125;", port); &#125; return future; &#125; protected ChannelInitializer&lt;Channel&gt; createInitializer(ChannelGroup channelGroup) &#123; return new ChatServerInitializer(channelGroup); &#125; protected void destroy() &#123; if (channel != null) &#123; channel.close(); &#125; channelGroup.close(); bossGroup.shutdownGracefully(); workGroup.shutdownGracefully(); &#125; public static void main(String[] args) &#123; new ChatServer().start(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940import io.netty.channel.Channel;import io.netty.channel.ChannelInitializer;import io.netty.channel.group.ChannelGroup;import io.netty.example.ws.initializer.SecureChatServerInitializer;import io.netty.handler.ssl.SslContext;import io.netty.handler.ssl.SslContextBuilder;import io.netty.handler.ssl.util.SelfSignedCertificate;import javax.net.ssl.SSLException;import java.security.cert.CertificateException;/** * SecureChatServer * * @author wusonghui@bubi.cn * @date 2020-02-05 21:35 * @since 1.0.0 */public class SecureChatServer extends ChatServer &#123; private final SslContext sslContext; public SecureChatServer(SslContext sslContext) &#123; this.sslContext = sslContext; &#125; @Override protected ChannelInitializer&lt;Channel&gt; createInitializer(ChannelGroup channelGroup) &#123; return new SecureChatServerInitializer(channelGroup, sslContext); &#125; public static void main(String[] args) &#123; try &#123; SelfSignedCertificate certificate = new SelfSignedCertificate(); SslContext sslContext = SslContextBuilder.forServer(certificate.certificate(), certificate.privateKey()).build(); new SecureChatServer(sslContext).start(); &#125; catch (SSLException | CertificateException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最后聊聊连续差不多两周的学习，通过看书+练习的操作，让自己能够将书上的知识，真的运用起来，并且进一步加深理解。刻意练习真的太重要，如果光看不练，就是纸上谈兵。]]></content>
      <tags>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google's Elite Security Team, Project Zero]]></title>
    <url>%2F2020%2F01%2F04%2FGoogle-Elite-Security-Team-Project-Zero%2F</url>
    <content type="text"><![CDATA[阅读When Apple launched the iPhone through an exclusive partnership with AT&amp;T in 2007, seventeen-year-old George Hotz wanted to use an iPhone but not with AT&amp;T. He wanted to make calls through hsi own T-Mobile network, so he cracked AT&amp;T’s lock on the iPhone. Apple scrambled to fix the bug that allowed this, but offcially ignored George Hotz. Later in 2011, Hotz reverse engineered the Playstion 3 and posted a copy of the root keys on his website. Snoy sued him but settled after Hotz promise never to hack Sony products again. Then in early 2014, at Google’s hacking competition, Hotz discovered a security hole in Google’s Chrome OS. The company gave him $150,000 reward. Two months later, Google’s security engineer Chris Evans offered him a position in a team of elite hackers. George Hotz accepted the offer and now workds for Google’s security team Project Zero. Project Zero worked in secret until Google publically revealed the team in July 2014. Its sole mission is tracking down and getting rid of security flaws in the world’s software. These flaws are called zero-day vulnerabilities, which are a common target of cyber criminals. Project Zero’s hackers aren’t just looking into the products that Google makes. They are free to hack any software in the world. Why? They want to make a safer Internet for everyone. The team’s plicy is simple. The team notifies vendors of vulnerabilities immediately, If fixes are not available within 90-days, bug reports automatically become available to the public. The 90-day diclosure policy appears to be working in most case. The Adobe Flash team fixed 37 Project Zero vulnerabilities(for 100%) within 90-day period. The Project Zero blog indicates that 85% of all velnerabilities are patched before the deadline. However, recently Google’s strict 90-day policy came under fire form Microsoft and Apple. The Project Zero ream publicly disclosed bugs which were present in Windows 8.1 and MacOS X before Microsoft and Apple released patches. Microsoft heavily criticized Google since the company was scheduled to realese a patch just two days later. Recently Google loosened its 90-day policy with an additional 14-day grace period. Now vendors have an addtional 14 days to patch vulnerabilities as long as the inform Google of the release schedule before the deadline. “People deserve to use the Internet without fear that vulnerabilities out there can ruin their privacy with a single website vistit. We’re goting to try to focus on the supply of these hight value vulnerabilities and elimnate them.” says Evans. 分析核心语法熟悉句式4 句式3为【主语 + 动词（vt） + 宾语】句式4为【主语 + 动词 + 宾语（间接宾语） + 宾语（直接宾语）】 The company gave him a reward.公司给他奖励。 Chris Evans offered him a position.克里斯·埃文斯提供给他一个职位。 The team notifies vendor of vulnerabilities.团队向厂商通报漏洞。中国式英语：The team notifies vendosrs vulnerablities.(X) They inform Google of the release schedule.他们向谷歌告知上线计划。中国式英语：They inform Google the release schedule.(X) 关系代名词that和which 关系代名词，连接两个句子，兼顾连词和代名词的作用。根据先行词和格种类不同，关系代名词也会相应发生变化。先行词，是修饰关系代名词从句的名词。格在关系代名词从句中发挥作用。 The team disclosed bugs. They were present in Windows 8.1.等同于：The team disclosed bugs that were present in Windows 8.1.The team disclosed bugs which were present in Windows 8.1. 先行词bugs指物，主语是they，此时用主格关系代名词that或者which。团队公布了bug，他们存在于Windows 8.1。 The hackers are looking into the products. Google makes them.等同于：The hackers are looking into the products that Google makes them.The hackers are looking into the products which Google makes them. 先行词the products指物，宾语是them，此时用主格关系代名词that或者which。黑客们调查产品谷歌制造的。 关系代名词引导非限定性定语从句熟悉关系代名词引导非限定性定语从句。这类词用于补充说明前文的内容。关系代名词前面加（,）可以理解为【连接词 + 代名词】，也是关系代名词引导非限定性定语从句和关系代名词引导限定性定语从句的区别，后面我们慢慢探索和掌握 These flaws are called zero-day vulnerabilities, and they are a common target of cyber criminals.等同于：These flaws are called zero-day vulnerabilities which are a common target of cyber criminals. 先行词vulnerabilities指物，主语为they，此时用主格关系代名词which，引导非限定性定语从句时候不能用that。]]></content>
      <tags>
        <tag>English,英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Study English One Day]]></title>
    <url>%2F2020%2F01%2F02%2FStudy-English-One-Day%2F</url>
    <content type="text"><![CDATA[2020年立个flat 刻意学习和练习英语 跟着《程序员的英语》学起英语来。 五个基本基本句式句式1为【主语 + 动词（vi）】，是基本句式 vi，不及物动词，不能直接跟宾语，需要一些介词跟着，例如，to，of，at等 He made toward the center station.他（He，主语） 向中央车站 走过去（toward，动词）。 句式2为【主语 + 动词 + 补语】 补语，对主语的补充说明 He will make a good programer.他（He，主语） 将要成为（make，动词） 一名优秀的程序员（programer，补语，对主语他的补充说明）。 句式3为【主语 + 动词（vt） + 宾语】句式2和句式3的区分方式是，如果一般动词可以用be动词代替，则属于句式2，否则是句式3 vt 及物动词，能够直接宾语 Make hay while the sun shines.晒（make，动词） 干草（hay，名词） 需要好太阳（sun，主语）。（寓意，看好时机干活） 句式4为【主语 + 动词 + 宾语（间接宾语） + 宾语（直接宾语）】He made me the simple dudoku app.他（He，主语） 给我（me，间接宾语） 做（made，动词）了 一个简单的数独app（直接宾语）。 句式5为【主语 + 动词 + 宾语 + 补语】，宾语和补语是可以同时出的。宾补，可以是不定式to、现在分词、过去分词等He made her happy.他（He，主语）使（made，动词）她（her，宾语）幸福（happy，补语）]]></content>
      <tags>
        <tag>English,英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String of Java]]></title>
    <url>%2F2019%2F08%2F25%2FString-of-Java%2F</url>
    <content type="text"><![CDATA[String 概括 string 名次，意思可以翻译为：线，弦，细绳；一串，一行等 再来看看String的类图，String的value是不是感觉很应景呢？一个个字符，串起来变成我们熟悉的字符串。这里有两个关键的field：value和hash。 String 三连击String变量到底存储在哪里？（JDK8)1234public class StringDemo &#123; public static void main(String[] args) &#123; String hello = "hello"; &#125; 通过命令 javap -v StringDemo.class 对编译后的文件进行编码，会看到以下内容： 1234567public class cn.hy.study.string.StringDemo minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#20 // java/lang/Object."&lt;init&gt;":()V #2 = String #16 // hello 可以看到，hello 这个字符串被存在了常量池（Constant pool）中，那么常量池又会存在哪里呢？ 通过下面代码，我们来看看jdk 1.8 的常量池是存在哪一块：1234567String hello = "hello";ArrayList list = new ArrayList();for (; ; ) &#123; String tmp = hello + new Random().nextInt(); hello = tmp; list.add(tmp.intern());&#125; jvm参数添加：-Xmx2m -XX:+PrintGCDetails 之后，运行不到一会儿，估计就会有下面的提醒了： 12341.8Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at ... 1231.7Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:2367) 1231.6Exception in thread "main" java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) 堆的内存分布： 1234567891011121314151617181920212223242526272829301.8Heap PSYoungGen total 1024K, used 17K [...) eden space 512K, 3% used [...) from space 512K, 0% used [...) to space 512K, 0% used [...) ParOldGen total 512K, used 401K [...) object space 512K, 78% used [...) Metaspace used 2728K, capacity 4486K, committed 4864K, reserved 1056768K class space used 291K, capacity 386K, committed 512K, reserved 1048576K1.7Heap PSYoungGen total 2048K, used 22K [...) eden space 1024K, 2% used [...) from space 1024K, 0% used [...) to space 1024K, 0% used [...) ParOldGen total 4096K, used 267K [...) object space 4096K, 6% used [...) PSPermGen total 21504K, used 2652K [...) object space 21504K, 12% used [...)1.6Heap par new generation total 1152K, used 41K [...) eden space 1024K, 4% used [...) from space 128K, 0% used [...) to space 128K, 0% used [...) concurrent mark-sweep generation total 5312K, used 279K [...) concurrent-mark-sweep perm gen total 83968K, used 4693K [...) 我们知道jvm的内存结构，分为，堆、栈、方法区。从上面，我可以看到jdk 1.8 中字符串常量池存在于jvm的堆内存中。综上所诉，可以看到 注：PermGen space 全程 Permanent Generation space 永久的产生的空间，也就是常说的永久代，在1.8以后已经被Meta space所代替。 String哪个方法最重要？从问题一我们可以知道，字符串是保存到常量池中，但是常量池中保存到字符串是如何快速返回字符串给调用方呢？如果让我来设计，我会将它放在哈希表中，通过合理设计hash函数，使得字符串合理分布在哈希表中，使得我们能迅速获取已经存在常量池中的字符串。下面是String的hashCode方法： 1234567891011121314/** Cache the hash code for the string */private int hash; // Default to 0public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 这里最难理解就是： 1234for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i];&#125;--&gt; s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 这里为啥是31 * h根据资料查阅，加上自己的一些理解，我觉得比较合理的解释： 31 * h == (h &lt;&lt; 5) - h，VM优化成位运算，使得计算hash code 性能更好 31 是一个不大不小的奇质数，也可以使得 hashCode 尽可能均匀分布。 除了以上，我们还可以发现一个有趣的地方 if (h == 0 &amp;&amp; value.length &gt; 0) ，这里用到了闪存散列代码（caching the hash code），无需二次计算 hash code，是一个比较典型空间换时间的应用，它之所以行之有效，其实有一个大前提就是String是final/immutable。 哈希表，搜索的平均时间复杂度为：O(1)，最坏的时间复杂度：O(n)。质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。 String哪个方法体逻辑最难懂，分享出来。个人觉得 split 方法是在String中相对比较难懂。12345678910111213141516 /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters ".$|()[&#123;^?*+\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */if (((regex.value.length == 1 &amp;&amp; ".$|()[&#123;^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; 这个if语句想判断 regex 是否为 fastpath 而不是正则表达式，否则直接跑下面的代码:1return Pattern.compile(regex).split(this, limit); 所以用这个API的时候，我们最好不要使用 &quot;.$|()[{^?*+\\&quot; 中的字符来进行分割，如果实在要用 需要通过 \\ 来转义。举个栗子：12345String s = "A,b|中,c";for (String word : s.split("\\|")) &#123; System.out.println(word);&#125; 输出结果为：12A,b中,c 分析完，感觉最困难的return Pattern.compile(regex).split(this, limit); 并没有分析到，下次如果有深入了解正则表达式的想法可以死磕一波。 参考 Java 中的 String.hashCode() 方法可能有问题？ why-does-javas-hashcode-in-string-use-31-as-a-multiplier 科普：为什么 String hashCode 方法选择数字31作为乘子 Effective Java 数据结构与算法分析 Java语言描述]]></content>
      <tags>
        <tag>Java,Java基础,hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你喜欢技术吗？]]></title>
    <url>%2F2019%2F07%2F13%2F%E4%BD%A0%E5%96%9C%E6%AC%A2%E6%8A%80%E6%9C%AF%E5%90%97%2F</url>
    <content type="text"><![CDATA[技术的本身是什么？我从维基百科找了一个差不多定义 技术可以指人类对机器、硬件或人造器皿的运用，但它也可以包含更广的架构，如系统、组织方法学和技巧。 我的成长印记那一年春节那一年春节（约2005年），我哥苦苦哀求老爸买下叔叔自己组装的电脑的情景。现在回想起来，我的技术成长的印记最初应该是从那时候开始。叔叔送我们一本厚厚的关于计算机的书，里面介绍了计算机的基本组成，一些常用的问题的处理等等。我从小不太喜欢看书，我竟然为了计算机把书啃完了。当我掌握了修电脑的技能后，村里如果谁家的电脑有问题了，就叫我去帮忙看看，但是也试过删除人家整个硬盘的资料，然后花了一个晚上慢慢找回数据。 数码产品高中那三年，抱着智能手机过来的，从最初的塞班爱好者，到Windows Mobile 手机，再到后来的安卓和iOS，都是让我如痴如醉，那时候安卓刚刚出来的时候，强行将自己的Windows mobile 手机刷成安卓系统，后来热的不行，冬天的时候刚刚可以当成暖手宝。安卓就是刷机，刷成瘾，帮雷总测试miui，到后来拿到全国第一批的小米1，然后转手卖掉，赚了几百块钱，也是美滋滋。 大学学渣高考过后，填写志愿所有的学校报都是软件工程，当时想法很单纯，就是想学习计算机软件相关的东西。暑假的时候买一本c语言相关的书籍，提前自学了。大一，经过媳妇（那时候还没有在一起哈哈）给我恶补的离散数学和高数还好没有挂科。大二，学完c++，还有数据结构等课程，现在想起来好像都还给老师了，最近也在恶补这个方面的东西。大三，基本开始Java 和安卓这些课程了。大四，基本不再上课，很多同学开始实习了，最后我也坐不住了，趁着暑假的时候，我也进去第一家公司去实习了，就这样子踏上了不归路了。 几大学最后悔的事情，就是没有参加过一次编程比赛，如果有还在读书的小伙伴，记得一定不要让自己后悔了。 从代码的搬运工，真正的搬砖从开始，工作只是为了完成上级交给的任务。很少思考，这个需求的真实内在需求。但是，慢慢会发现，工作其实不是想象中那么简单的。很多时候，需求你的理解是这样子，产品的理解是那样子，很容易出现xy问题。所以，沟通理解 十分重要，一定要准确表达自己的意思，也要力求理解别人说的，至少在百分之五十左右，不然会严重的问题。例如，做完了需求，产品说这个不是他想要的，这个就很操蛋了。可能说偏了，但是沟通好了，肯定是有助于提高我们的技术。2017年的时候，我的上级在指导我的时候，由于我的表达和理解不到位，差点吵起来了，但是坐下来，好好想一下，才知道上级的真正表达的意思。如果我们的沟通理解能力越强，技术的提升会更加快。 技术给你的成就感是什么？计算机给我的成就感，就是能帮助到别人我就很开心，当然不小心格式化了别人的硬盘我也会很不开心。软件开发，给我成就感，从最初的一次次任务的完成就很满足，到现在的方案是否为最优才会有成就感。一个产品经理跟我说，只有有价值的东西，才有可能会存在。现在，会思考自己做的东西是否有价值，如果觉得是无价值的东西，有时候会感觉成就感很低。 最后，我觉得技术，不单单是指软件开发本身，更多说的是思维的模式，只有不断思考，我们的技术才会越来越来好。 看山是山，看山不是山，看山还是山。 少吃零食，多看书，多看报，多思考，多睡觉。如果尽信书不如无书，所以每个人都需要有自己的思考能力。做人嘛，最紧要就系开心😄！！！全世界晚安！！！]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的包装类型]]></title>
    <url>%2F2019%2F04%2F03%2FJava%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概述顾名思义，包装类型就是对基本类型的封装的对象。 基本类型 包装类型 大小 默认值 boolean Boolean 1B false byte Byte 1B 0 short Short 2B 0 char Character 2B ‘\u0000’ int Integer 4B 0 long Long 8B 0L float Float 4B 0.0f double Double 8B 0.0d 包装类型为啥需要包装类型？将基本类型封装成对象，提供更多的功能，解决基础类型无法解决的问题：泛型类型参数、序列化、数据类型转换、高频区间数据缓存。例如： 泛型类型参数的问题：List&lt;int&gt; list; 这种定义是否无法通过编译的，需要将int 转成对应的包装类型 Integer ，才运行添加到集合中； 类型转换的问题：提供 Integer.valueOf(&quot;123&quot;) 将字符串转成数字的功； 高频区间数据缓存的问题：Integer.java 源码中 valueOf(int i) 的方法，提供 -128~127高频区间的数据缓存。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 包装类型和基本类型的互相转化JDk 5 以前没有自动拆装箱，可以通过下面的方式进行装箱和拆箱： 1234// 装箱Long wrapperLong = new Long(1);// 拆箱long aLong = wrapperLong.longValue(); 拥有了自动拆装箱的代码，相对会简洁一些： 1234// 自动装箱Long wrapperLong = 1L;// 自动拆箱long aLong = wrapperLong; 简单的例子，说明一下它们的区别源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 基础类型学习，如果两个数 相等，相加后返回，否则直接返回第一个参数。 * * @author wusonghui@bubi.cn * @since 1.0.0 2019-04-02 15:01 */public class PrimitiveTypeStudy &#123; public static void main(String[] args) &#123; // 自动装箱 Long wrapperLong = 1L; // 自动拆箱 long aLong = wrapperLong; add(Long.valueOf(1L), Long.valueOf(1L)); add(Long.valueOf(1L), 1L); add(1L, 1L); &#125; /** * 测试 所有数据都为 长整型 包装类型 * * @param first 长整型 包装类型 * @param second 长整型 包装类型 * @return 长整型 包装类型 */ public static Long add(Long first, Long second) &#123; if (first.equals(second)) &#123; return first + second; &#125; return first; &#125; /** * 测试 second 参数为 基本类型，其他均为 包装类型 * * @param first 长整型 包装类型 * @param second 长整型 基本类型 * @return 长整型 包装类型 */ public static long add(Long first, long second) &#123; if (first.equals(second)) &#123; return first + second; &#125; return first; &#125; /** * 测试 所有数据都为 长整型 基本类型 * * @param first 长整型 基本类型 * @param second 长整型 基本类型 * @return 长整型 包装类型 */ public static long add(long first, long second) &#123; if (first == second) &#123; return first + second; &#125; return first; &#125;&#125; 反编译回来的代码： 123456789101112131415161718192021222324252627282930313233343536373839package cn.hy.study.basictype;import java.io.PrintStream;public class PrimitiveTypeStudy&#123; public static void main(String[] args) &#123; Long wrapperLong = Long.valueOf(1L); long aLong = wrapperLong.longValue(); add(Long.valueOf(1L), Long.valueOf(1L)); add(Long.valueOf(1L), 1L); add(1L, 1L); &#125; public static Long add(Long first, Long second) &#123; if (first.equals(second)) &#123; return Long.valueOf(first.longValue() + second.longValue()); &#125; return first; &#125; public static long add(Long first, long second) &#123; if (first.equals(Long.valueOf(second))) &#123; return first.longValue() + second; &#125; return first.longValue(); &#125; public static long add(long first, long second) &#123; if (first == second) &#123; return first + second; &#125; return first; &#125;&#125; 通过javap -v -p PrimitiveTypeStudy.class 命令生成，字节码内容，为了对比的效果，我在前后加入反编译后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277Classfile /Users/jaryoung/project/demo/javabasic/out/production/classes/cn/hy/study/basictype/PrimitiveTypeStudy.class Last modified Apr 3, 2019; size 1530 bytes MD5 checksum db6d2b4373555e4e52196d58a3ba87b5 Compiled from "PrimitiveTypeStudy.java"public class cn.hy.study.basictype.PrimitiveTypeStudy minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #19.#44 // java/lang/Object."&lt;init&gt;":()V #2 = Class #45 // java/lang/Long #3 = Methodref #2.#46 // java/lang/Long."&lt;init&gt;":(J)V #4 = Methodref #2.#47 // java/lang/Long.longValue:()J #5 = Fieldref #48.#49 // java/lang/System.out:Ljava/io/PrintStream; #6 = Class #50 // java/lang/StringBuilder #7 = Methodref #6.#44 // java/lang/StringBuilder."&lt;init&gt;":()V #8 = String #51 // #9 = Methodref #6.#52 // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #10 = Methodref #6.#53 // java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; #11 = Methodref #6.#54 // java/lang/StringBuilder.toString:()Ljava/lang/String; #12 = Methodref #55.#56 // java/io/PrintStream.println:(Ljava/lang/String;)V #13 = Methodref #2.#57 // java/lang/Long.valueOf:(J)Ljava/lang/Long; #14 = Methodref #18.#58 // cn/hy/study/basictype/PrimitiveTypeStudy.add:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; #15 = Methodref #18.#59 // cn/hy/study/basictype/PrimitiveTypeStudy.add:(Ljava/lang/Long;J)J #16 = Methodref #18.#60 // cn/hy/study/basictype/PrimitiveTypeStudy.add:(JJ)J #17 = Methodref #2.#61 // java/lang/Long.equals:(Ljava/lang/Object;)Z #18 = Class #62 // cn/hy/study/basictype/PrimitiveTypeStudy #19 = Class #63 // java/lang/Object #20 = Utf8 &lt;init&gt; #21 = Utf8 ()V #22 = Utf8 Code #23 = Utf8 LineNumberTable #24 = Utf8 LocalVariableTable #25 = Utf8 this #26 = Utf8 Lcn/hy/study/basictype/PrimitiveTypeStudy; #27 = Utf8 main #28 = Utf8 ([Ljava/lang/String;)V #29 = Utf8 args #30 = Utf8 [Ljava/lang/String; #31 = Utf8 wrapperLong #32 = Utf8 Ljava/lang/Long; #33 = Utf8 aLong #34 = Utf8 J #35 = Utf8 add #36 = Utf8 (Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; #37 = Utf8 first #38 = Utf8 second #39 = Utf8 StackMapTable #40 = Utf8 (Ljava/lang/Long;J)J #41 = Utf8 (JJ)J #42 = Utf8 SourceFile #43 = Utf8 PrimitiveTypeStudy.java #44 = NameAndType #20:#21 // "&lt;init&gt;":()V #45 = Utf8 java/lang/Long #46 = NameAndType #20:#64 // "&lt;init&gt;":(J)V #47 = NameAndType #65:#66 // longValue:()J #48 = Class #67 // java/lang/System #49 = NameAndType #68:#69 // out:Ljava/io/PrintStream; #50 = Utf8 java/lang/StringBuilder #51 = Utf8 #52 = NameAndType #70:#71 // append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #53 = NameAndType #70:#72 // append:(J)Ljava/lang/StringBuilder; #54 = NameAndType #73:#74 // toString:()Ljava/lang/String; #55 = Class #75 // java/io/PrintStream #56 = NameAndType #76:#77 // println:(Ljava/lang/String;)V #57 = NameAndType #78:#79 // valueOf:(J)Ljava/lang/Long; #58 = NameAndType #35:#36 // add:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; #59 = NameAndType #35:#40 // add:(Ljava/lang/Long;J)J #60 = NameAndType #35:#41 // add:(JJ)J #61 = NameAndType #80:#81 // equals:(Ljava/lang/Object;)Z #62 = Utf8 cn/hy/study/basictype/PrimitiveTypeStudy #63 = Utf8 java/lang/Object #64 = Utf8 (J)V #65 = Utf8 longValue #66 = Utf8 ()J #67 = Utf8 java/lang/System #68 = Utf8 out #69 = Utf8 Ljava/io/PrintStream; #70 = Utf8 append #71 = Utf8 (Ljava/lang/String;)Ljava/lang/StringBuilder; #72 = Utf8 (J)Ljava/lang/StringBuilder; #73 = Utf8 toString #74 = Utf8 ()Ljava/lang/String; #75 = Utf8 java/io/PrintStream #76 = Utf8 println #77 = Utf8 (Ljava/lang/String;)V #78 = Utf8 valueOf #79 = Utf8 (J)Ljava/lang/Long; #80 = Utf8 equals #81 = Utf8 (Ljava/lang/Object;)Z&#123; public cn.hy.study.basictype.PrimitiveTypeStudy(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 14: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcn/hy/study/basictype/PrimitiveTypeStudy; /* public static void main(String[] args) &#123; Long wrapperLong = Long.valueOf(1L); long aLong = wrapperLong.longValue(); add(Long.valueOf(1L), Long.valueOf(1L)); add(Long.valueOf(1L), 1L); add(1L, 1L); &#125; */ public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=4, args_size=1 0: new #2 // class java/lang/Long 3: dup 4: lconst_1 5: invokespecial #3 // Method java/lang/Long."&lt;init&gt;":(J)V 8: astore_1 9: aload_1 10: invokevirtual #4 // Method java/lang/Long.longValue:()J 13: lstore_2 14: getstatic #5 // Field java/lang/System.out:Ljava/io/PrintStream; 17: new #6 // class java/lang/StringBuilder 20: dup 21: invokespecial #7 // Method java/lang/StringBuilder."&lt;init&gt;":()V 24: ldc #8 // String 26: invokevirtual #9 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 29: lload_2 30: invokevirtual #10 // Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; 33: invokevirtual #11 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 36: invokevirtual #12 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: lconst_1 40: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 43: lconst_1 44: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 47: invokestatic #14 // Method add:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; 50: pop 51: lconst_1 52: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 55: lconst_1 56: invokestatic #15 // Method add:(Ljava/lang/Long;J)J 59: pop2 60: lconst_1 61: lconst_1 62: invokestatic #16 // Method add:(JJ)J 65: pop2 66: return LineNumberTable: line 19: 0 line 21: 9 line 22: 14 line 23: 39 line 24: 51 line 25: 60 line 29: 66 LocalVariableTable: Start Length Slot Name Signature 0 67 0 args [Ljava/lang/String; 9 58 1 wrapperLong Ljava/lang/Long; 14 53 2 aLong J /* public static Long add(Long first, Long second) &#123; if (first.equals(second)) &#123; return Long.valueOf(first.longValue() + second.longValue()); &#125; return first; &#125; */ public static java.lang.Long add(java.lang.Long, java.lang.Long); descriptor: (Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=2, args_size=2 0: aload_0 1: aload_1 2: invokevirtual #17 // Method java/lang/Long.equals:(Ljava/lang/Object;)Z 5: ifeq 21 8: aload_0 9: invokevirtual #4 // Method java/lang/Long.longValue:()J 12: aload_1 13: invokevirtual #4 // Method java/lang/Long.longValue:()J 16: ladd 17: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 20: areturn 21: aload_0 22: areturn LineNumberTable: line 39: 0 line 40: 8 line 42: 21 LocalVariableTable: Start Length Slot Name Signature 0 23 0 first Ljava/lang/Long; 0 23 1 second Ljava/lang/Long; StackMapTable: number_of_entries = 1 frame_type = 21 /* same */ /* public static long add(Long first, long second) &#123; if (first.equals(Long.valueOf(second))) &#123; return first.longValue() + second; &#125; return first.longValue(); &#125; */ public static long add(java.lang.Long, long); descriptor: (Ljava/lang/Long;J)J flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=3, args_size=2 0: aload_0 1: lload_1 2: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 5: invokevirtual #17 // Method java/lang/Long.equals:(Ljava/lang/Object;)Z 8: ifeq 18 11: aload_0 12: invokevirtual #4 // Method java/lang/Long.longValue:()J 15: lload_1 16: ladd 17: lreturn 18: aload_0 19: invokevirtual #4 // Method java/lang/Long.longValue:()J 22: lreturn LineNumberTable: line 53: 0 line 54: 11 line 56: 18 LocalVariableTable: Start Length Slot Name Signature 0 23 0 first Ljava/lang/Long; 0 23 1 second J StackMapTable: number_of_entries = 1 frame_type = 18 /* same */ /* public static long add(long first, long second) &#123; if (first == second) &#123; return first + second; &#125; return first; &#125; */ public static long add(long, long); descriptor: (JJ)J flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=4, args_size=2 0: lload_0 1: lload_2 2: lcmp 3: ifne 10 6: lload_0 7: lload_2 8: ladd 9: lreturn 10: lload_0 11: lreturn LineNumberTable: line 68: 0 line 69: 6 line 71: 10 LocalVariableTable: Start Length Slot Name Signature 0 12 0 first J 0 12 2 second J StackMapTable: number_of_entries = 1 frame_type = 10 /* same */&#125;SourceFile: "PrimitiveTypeStudy.java" 结论除了 POJO 类属性 和 RPC 方法的返回值和参数之外，其他情况建议使用基本类型。 部分内容都是引用自： 《码出高效》https://www.baeldung.com/java-wrapper-classes]]></content>
      <tags>
        <tag>Java,Java基础,Java数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Docker（针对开发人员）]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%88%9D%E8%AF%86Docker%2F</url>
    <content type="text"><![CDATA[概括Docker 是世界领先的软件容器平台。开发人员利用 Docker 可以解决，“在我的机器上可正常工作的啊！！！”的问题 容器又是什么东西？容器是一种标准化的软件单元。容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。 图片出自：https://www.docker-cn.com/what-container 容器和虚拟机 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。 容器和虚拟机对比 容器 虚拟机 容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。 虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因 图片出自：https://www.docker-cn.com/what-container 图片出自：https://www.docker-cn.com/what-container 容器和虚拟机共用 将容器和虚拟机配合使用，为应用的部署和管理提供极大的灵活性。 图片出自：https://www.docker-cn.com/what-container 获取docker（针对Mac 用户） 建议注册一个账户 然后通过官网链接下载桌面版的Docker，官网超链接，如果想快一点可以试试看这个链接 。(默认最新稳定版) 下载完，安装好，配置一下Docker 中国官方镜像加速源 http://registry.docker-cn.com，当然你也是可以选择其他的加速源例如阿里，网易等等。配置完，记得点击Apply&amp;Restart。 打开Terminal ，输入一下命令 docker info 安装工具，到此结束了，是不是想说So easy？其实就是如此轻松，马上可以享受到Docker带来的快感吧！ 使用Docker我习惯上来先查一下，help（不想看，直接跳过哈，下面会开始讲，我目前经常使用的一些命令。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576docker helpUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default "/Users/jaryoung/.docker") -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default "/Users/jaryoung/.docker/ca.pem") --tlscert string Path to TLS certificate file (default "/Users/jaryoung/.docker/cert.pem") --tlskey string Path to TLS key file (default "/Users/jaryoung/.docker/key.pem") --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: builder Manage builds config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumesCommands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codesRun 'docker COMMAND --help' for more information on a command. docker search1234567891011docker search --helpUsage: docker search [OPTIONS] TERMSearch the Docker Hub for images，为了在Docker Hub上面搜 **资源**（你们都懂得）Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output 例如，我需要搜索一下上面有哪些mysql镜像，我们可以看到下面到信息： 123456docker search mysqlNAME（名称） DESCRIPTION（描述） STARS（多少次好评） OFFICIAL（官方） AUTOMATED（自动化）mysql MySQL is a widely used, open-source relation… 7964 [OK]mariadb MariaDB is a community-developed fork of MyS… 2665 [OK]mysql/mysql-server Optimized MySQL Server Docker images. Create… 598 [OK]... docker pull123456789docker pull --helpUsage: docker pull [OPTIONS] NAME[:TAG|@DIGEST]Pull an image or a repository from a registryOptions: -a, --all-tags Download all tagged images in the repository --disable-content-trust Skip image verification (default true) 例如，我们可以通过 docker pull mysql , 来下载最新版的mysql镜像。如果需要带上TAG，例如 docker pull mysql:5.7 docker run123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354docker run --helpUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]Run a command in a new containerOptions(删除了一部分，详细的情况，可以自己查询): --add-host list Add a custom host-to-IP mapping (host:ip) -d, --detach Run container in background and print container ID --detach-keys string Override the key sequence for detaching a container --device list Add a host device to the container --device-cgroup-rule list Add a rule to the cgroup allowed devices list --device-read-bps list Limit read rate (bytes per second) from a device (default []) --device-read-iops list Limit read rate (IO per second) from a device (default []) --device-write-bps list Limit write rate (bytes per second) to a device (default []) --device-write-iops list Limit write rate (IO per second) to a device (default []) --disable-content-trust Skip image verification (default true) --dns list Set custom DNS servers --dns-option list Set DNS options --dns-search list Set custom DNS search domains --entrypoint string Overwrite the default ENTRYPOINT of the image -e, --env list Set environment variables --env-file list Read in a file of environment variables --expose list Expose a port or a range of ports --group-add list Add additional groups to join --health-cmd string Command to run to check health --health-interval duration Time between running the check (ms|s|m|h) (default 0s) --health-retries int Consecutive failures needed to report unhealthy --health-start-period duration Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s) --health-timeout duration Maximum time to allow one check to run (ms|s|m|h) (default 0s) --help Print usage -h, --hostname string Container host name --init Run an init inside the container that forwards signals and reaps processes -p, --publish list Publish a container's port(s) to the host -P, --publish-all Publish all exposed ports to random ports --read-only Mount the container's root filesystem as read only --restart string Restart policy to apply when a container exits (default "no") --rm Automatically remove the container when it exits --runtime string Runtime to use for this container --security-opt list Security Options --shm-size bytes Size of /dev/shm --sig-proxy Proxy received signals to the process (default true) --stop-signal string Signal to stop a container (default "SIGTERM") --stop-timeout int Timeout (in seconds) to stop a container --storage-opt list Storage driver options for the container --sysctl map Sysctl options (default map[]) --tmpfs list Mount a tmpfs directory -t, --tty Allocate a pseudo-TTY --ulimit ulimit Ulimit options (default []) ... -v, --volume list Bind mount a volume --volume-driver string Optional volume driver for the container --volumes-from list Mount volumes from the specified container(s) -w, --workdir string Working directory inside the container Mysql1docker run -p 3306:3306 --name mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6.43 -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。 -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。 -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。 -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。 -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 Redis1docker run -p 6379:6379 -v $PWD/data:/data --name redis -d redis redis-server --appendonly yes 命令说明： -p 6379:6379 : 将容器的6379端口映射到主机的6379端口 -v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data redis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 Nginx首先，我需要创建一下，文件夹,用于主宿机之间做映射使用。 1mkdir -p &#123;conf.d,html,logs&#125; 1docker run -p 80:80 -p 84:84 -p 82:82 --name nginx -v $PWD/www:/www -v $PWD/html:/usr/share/nginx/html -v $PWD/logs:/wwwlogs -v $PWD/conf.d:/etc/nginx/conf.d -d nginx 命令说明： -p 80:80：主机80到容器80，-p 84:84，同理（主机 -&gt; 宿机） –name mynginx：将容器命名为nginx -v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www -v $PWD/conf/conf.d:/etc/nginx/conf.d：将主机中当前目录下的conf.d挂载到容器的/etc/nginx/conf.d 不能挂载文件，只能挂载文件夹 注意如果提醒你，是否不应该将一个文件夹挂载到文件下面，我需要自己手动创建一个nginx.conf配置文件，并放置到主机的映射配置文件夹中（$PWD/conf），重新执行即可。如果出现了没有访问你配置的静态资源，很可能是访问到默认的配置（conf.d/default.conf）,可以选择删除它，也可以选择覆盖/etc/nginx/nginx.conf，但是前提需要备份原来的nginx.conf或者在原nginx.conf上做修改会更加适合。 -v $PWD/html:/usr/share/nginx/html，讲主机中当前的目录下的文件夹挂载到容器中 这里映射不正确，很有可能导致访问403 拒绝访问的情况，如果你的html不是资源访问的跟路径，请配置正确的根路径，例如，资源是放在html/hello的文件中，需要配置到$PWD/html/hello，而不是$PWD/html。 -v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs docker ps123456789101112131415docker ps --helpUsage: docker ps [OPTIONS]List containersOptions: -a, --all Show all containers (default shows just running) -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template -n, --last int Show n last created containers (includes all states) (default -1) -l, --latest Show the latest created container (includes all states) --no-trunc Don't truncate output -q, --quiet Only display numeric IDs -s, --size Display total file sizes 例如，我们可以运行 docker ps -a ,查询一下我们容器中启动的镜像的情况： 1234CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4b9f565ae5ad nginx "nginx -g 'daemon of…" 8 hours ago Up 4 minutes 0.0.0.0:84-&gt;80/tcp nginx46519e512d58 redis "docker-entrypoint.s…" 10 hours ago Up 5 minutes 0.0.0.0:6379-&gt;6379/tcp redis293c9831f58a mysql:5.6.43 "docker-entrypoint.s…" 10 hours ago Up 4 minutes 0.0.0.0:3306-&gt;3306/tcp mysql 命令说明： -a Show all containers (default shows just running)，会显示所有存在的，默认是之后显示当前容器启动的镜像。 docker stop12345678docker stop --helpUsage: docker stop [OPTIONS] CONTAINER [CONTAINER...]Stop one or more running containersOptions: -t, --time int Seconds to wait for stop before killing it (default 10) docker start12345678910docker start --helpUsage: docker start [OPTIONS] CONTAINER [CONTAINER...]Start one or more stopped containers，可以启动一个或者多个容器Options: -a, --attach Attach STDOUT/STDERR and forward signals --detach-keys string Override the key sequence for detaching a container -i, --interactive Attach container's STDIN 例如，我们可以通过 docker start nginx mysql ，同时启动两个容器 docker exec123456789101112131415docker exec --helpUsage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...]Run a command in a running containerOptions: -d, --detach Detached mode: run command in the background --detach-keys string Override the key sequence for detaching a container -e, --env list Set environment variables -i, --interactive Keep STDIN open even if not attached --privileged Give extended privileges to the command -t, --tty Allocate a pseudo-TTY -u, --user string Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) -w, --workdir string Working directory inside the container 例如，我们可以通过命令快速进入到redis-cli，docker exec -it redis redis-cli，输入exit 就可以推出 很多内容都是引用自： http://www.runoob.com/docker/docker-tutorial.htmlhttps://www.docker-cn.com]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
