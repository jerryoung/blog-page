<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[String of Java]]></title>
    <url>%2F2019%2F08%2F25%2FString-of-Java%2F</url>
    <content type="text"><![CDATA[String 概括 string 名词，意思可以翻译为：线，弦，细绳；一串，一行等 再来看看String的类图，String的value是不是感觉很应景呢？一个个字符，串起来变成我们熟悉的字符串。这里有两个关键的field：value和hash。 String 三连击String变量到底存储在哪里？（JDK8)1234public class StringDemo &#123; public static void main(String[] args) &#123; String hello = "hello"; &#125; 通过命令 javap -v StringDemo.class 对编译后的文件进行编码，会看到以下内容： 1234567public class cn.hy.study.string.StringDemo minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#20 // java/lang/Object."&lt;init&gt;":()V #2 = String #16 // hello 可以看到，hello 这个字符串被存在了常量池（Constant pool）中，那么常量池又会存在哪里呢？ 通过下面代码，我们来看看jdk 1.8 的常量池是存在哪一块：1234567String hello = "hello";ArrayList list = new ArrayList();for (; ; ) &#123; String tmp = hello + new Random().nextInt(); hello = tmp; list.add(tmp.intern());&#125; jvm参数添加：-Xmx2m -XX:+PrintGCDetails 之后，运行不到一会儿，估计就会有下面的提醒了： 12341.8Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at ... 1231.7Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:2367) 1231.6Exception in thread "main" java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) 堆的内存分布： 1234567891011121314151617181920212223242526272829301.8Heap PSYoungGen total 1024K, used 17K [...) eden space 512K, 3% used [...) from space 512K, 0% used [...) to space 512K, 0% used [...) ParOldGen total 512K, used 401K [...) object space 512K, 78% used [...) Metaspace used 2728K, capacity 4486K, committed 4864K, reserved 1056768K class space used 291K, capacity 386K, committed 512K, reserved 1048576K1.7Heap PSYoungGen total 2048K, used 22K [...) eden space 1024K, 2% used [...) from space 1024K, 0% used [...) to space 1024K, 0% used [...) ParOldGen total 4096K, used 267K [...) object space 4096K, 6% used [...) PSPermGen total 21504K, used 2652K [...) object space 21504K, 12% used [...)1.6Heap par new generation total 1152K, used 41K [...) eden space 1024K, 4% used [...) from space 128K, 0% used [...) to space 128K, 0% used [...) concurrent mark-sweep generation total 5312K, used 279K [...) concurrent-mark-sweep perm gen total 83968K, used 4693K [...) 我们知道jvm的内存结构，分为，堆、栈、方法区。从上面，我可以看到jdk 1.8 中字符串常量池存在于jvm的堆内存中。综上所诉，可以看到 注：PermGen space 全程 Permanent Generation space 永久的产生的空间，也就是常说的永久代，在1.8以后已经被Meta space所代替。 String哪个方法最重要？从问题一我们可以知道，字符串是保存到常量池中，但是常量池中保存到字符串是如何快速返回字符串给调用方呢？如果让我来设计，我会将它放在哈希表中，通过合理设计hash函数，使得字符串合理分布在哈希表中，使得我们能迅速获取已经存在常量池中的字符串。下面是String的hashCode方法： 1234567891011121314/** Cache the hash code for the string */private int hash; // Default to 0public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 这里最难理解就是： 1234for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i];&#125;--&gt; s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 这里为啥是31 * h根据资料查阅，加上自己的一些理解，我觉得比较合理的解释： 31 * h == (h &lt;&lt; 5) - h，VM优化成位运算，使得计算hash code 性能更好 31 是一个不大不小的奇质数，也可以使得 hashCode 尽可能均匀分布。 除了以上，我们还可以发现一个有趣的地方 if (h == 0 &amp;&amp; value.length &gt; 0) ，这里用到了闪存散列代码（caching the hash code），无需二次计算 hash code，是一个比较典型空间换时间的应用，它之所以行之有效，其实有一个大前提就是String是final/immutable。 哈希表，搜索的平均时间复杂度为：O(1)，最坏的时间复杂度：O(n)。质数（Prime number），又称素数，指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数（也可定义为只有1与该数本身两个正因数的数）。 String哪个方法体逻辑最难懂，分享出来。个人觉得 split 方法是在String中相对比较难懂。12345678910111213141516 /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters ".$|()[&#123;^?*+\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */if (((regex.value.length == 1 &amp;&amp; ".$|()[&#123;^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; 这个if语句想判断 regex 是否为 fastpath 而不是正则表达式，否则直接跑下面的代码:1return Pattern.compile(regex).split(this, limit); 所以用这个API的时候，我们最好不要使用 &quot;.$|()[{^?*+\\&quot; 中的字符来进行分割，如果实在要用 需要通过 \\ 来转义。举个栗子：12345String s = "A,b|中,c";for (String word : s.split("\\|")) &#123; System.out.println(word);&#125; 输出结果为：12A,b中,c 分析完，感觉最困难的return Pattern.compile(regex).split(this, limit); 并没有分析到，下次如果有深入了解正则表达式的想法可以死磕一波。 参考 Java 中的 String.hashCode() 方法可能有问题？ why-does-javas-hashcode-in-string-use-31-as-a-multiplier 科普：为什么 String hashCode 方法选择数字31作为乘子 Effective Java 数据结构与算法分析 Java语言描述]]></content>
      <tags>
        <tag>Java,Java基础,hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你喜欢技术吗？]]></title>
    <url>%2F2019%2F07%2F13%2F%E4%BD%A0%E5%96%9C%E6%AC%A2%E6%8A%80%E6%9C%AF%E5%90%97%2F</url>
    <content type="text"><![CDATA[技术的本身是什么？我从维基百科找了一个差不多定义 技术可以指人类对机器、硬件或人造器皿的运用，但它也可以包含更广的架构，如系统、组织方法学和技巧。 我的成长印记那一年春节那一年春节（约2005年），我哥苦苦哀求老爸买下叔叔自己组装的电脑的情景。现在回想起来，我的技术成长的印记最初应该是从那时候开始。叔叔送我们一本厚厚的关于计算机的书，里面介绍了计算机的基本组成，一些常用的问题的处理等等。我从小不太喜欢看书，我竟然为了计算机把书啃完了。当我掌握了修电脑的技能后，村里如果谁家的电脑有问题了，就叫我去帮忙看看，但是也试过删除人家整个硬盘的资料，然后花了一个晚上慢慢找回数据。 数码产品高中那三年，抱着智能手机过来的，从最初的塞班爱好者，到Windows Mobile 手机，再到后来的安卓和iOS，都是让我如痴如醉，那时候安卓刚刚出来的时候，强行将自己的Windows mobile 手机刷成安卓系统，后来热的不行，冬天的时候刚刚可以当成暖手宝。安卓就是刷机，刷成瘾，帮雷总测试miui，到后来拿到全国第一批的小米1，然后转手卖掉，赚了几百块钱，也是美滋滋。 大学学渣高考过后，填写志愿所有的学校报都是软件工程，当时想法很单纯，就是想学习计算机软件相关的东西。暑假的时候买一本c语言相关的书籍，提前自学了。大一，经过媳妇（那时候还没有在一起哈哈）给我恶补的离散数学和高数还好没有挂科。大二，学完c++，还有数据结构等课程，现在想起来好像都还给老师了，最近也在恶补这个方面的东西。大三，基本开始Java 和安卓这些课程了。大四，基本不再上课，很多同学开始实习了，最后我也坐不住了，趁着暑假的时候，我也进去第一家公司去实习了，就这样子踏上了不归路了。 几大学最后悔的事情，就是没有参加过一次编程比赛，如果有还在读书的小伙伴，记得一定不要让自己后悔了。 从代码的搬运工，真正的搬砖从开始，工作只是为了完成上级交给的任务。很少思考，这个需求的真实内在需求。但是，慢慢会发现，工作其实不是想象中那么简单的。很多时候，需求你的理解是这样子，产品的理解是那样子，很容易出现xy问题。所以，沟通理解 十分重要，一定要准确表达自己的意思，也要力求理解别人说的，至少在百分之五十左右，不然会严重的问题。例如，做完了需求，产品说这个不是他想要的，这个就很操蛋了。可能说偏了，但是沟通好了，肯定是有助于提高我们的技术。2017年的时候，我的上级在指导我的时候，由于我的表达和理解不到位，差点吵起来了，但是坐下来，好好想一下，才知道上级的真正表达的意思。如果我们的沟通理解能力越强，技术的提升会更加快。 技术给你的成就感是什么？计算机给我的成就感，就是能帮助到别人我就很开心，当然不小心格式化了别人的硬盘我也会很不开心。软件开发，给我成就感，从最初的一次次任务的完成就很满足，到现在的方案是否为最优才会有成就感。一个产品经理跟我说，只有有价值的东西，才有可能会存在。现在，会思考自己做的东西是否有价值，如果觉得是无价值的东西，有时候会感觉成就感很低。 最后，我觉得技术，不单单是指软件开发本身，更多说的是思维的模式，只有不断思考，我们的技术才会越来越来好。 看山是山，看山不是山，看山还是山。 少吃零食，多看书，多看报，多思考，多睡觉。如果尽信书不如无书，所以每个人都需要有自己的思考能力。做人嘛，最紧要就系开心😄！！！全世界晚安！！！]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的包装类型]]></title>
    <url>%2F2019%2F04%2F03%2FJava%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概述顾名思义，包装类型就是对基本类型的封装的对象。 基本类型 包装类型 大小 默认值 boolean Boolean 1B false byte Byte 1B 0 short Short 2B 0 char Character 2B ‘\u0000’ int Integer 4B 0 long Long 8B 0L float Float 4B 0.0f double Double 8B 0.0d 包装类型为啥需要包装类型？将基本类型封装成对象，提供更多的功能，解决基础类型无法解决的问题：泛型类型参数、序列化、数据类型转换、高频区间数据缓存。例如： 泛型类型参数的问题：List&lt;int&gt; list; 这种定义是否无法通过编译的，需要将int 转成对应的包装类型 Integer ，才运行添加到集合中； 类型转换的问题：提供 Integer.valueOf(&quot;123&quot;) 将字符串转成数字的功； 高频区间数据缓存的问题：Integer.java 源码中 valueOf(int i) 的方法，提供 -128~127高频区间的数据缓存。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 包装类型和基本类型的互相转化JDk 5 以前没有自动拆装箱，可以通过下面的方式进行装箱和拆箱： 1234// 装箱Long wrapperLong = new Long(1);// 拆箱long aLong = wrapperLong.longValue(); 拥有了自动拆装箱的代码，相对会简洁一些： 1234// 自动装箱Long wrapperLong = 1L;// 自动拆箱long aLong = wrapperLong; 简单的例子，说明一下它们的区别源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 基础类型学习，如果两个数 相等，相加后返回，否则直接返回第一个参数。 * * @author wusonghui@bubi.cn * @since 1.0.0 2019-04-02 15:01 */public class PrimitiveTypeStudy &#123; public static void main(String[] args) &#123; // 自动装箱 Long wrapperLong = 1L; // 自动拆箱 long aLong = wrapperLong; add(Long.valueOf(1L), Long.valueOf(1L)); add(Long.valueOf(1L), 1L); add(1L, 1L); &#125; /** * 测试 所有数据都为 长整型 包装类型 * * @param first 长整型 包装类型 * @param second 长整型 包装类型 * @return 长整型 包装类型 */ public static Long add(Long first, Long second) &#123; if (first.equals(second)) &#123; return first + second; &#125; return first; &#125; /** * 测试 second 参数为 基本类型，其他均为 包装类型 * * @param first 长整型 包装类型 * @param second 长整型 基本类型 * @return 长整型 包装类型 */ public static long add(Long first, long second) &#123; if (first.equals(second)) &#123; return first + second; &#125; return first; &#125; /** * 测试 所有数据都为 长整型 基本类型 * * @param first 长整型 基本类型 * @param second 长整型 基本类型 * @return 长整型 包装类型 */ public static long add(long first, long second) &#123; if (first == second) &#123; return first + second; &#125; return first; &#125;&#125; 反编译回来的代码： 123456789101112131415161718192021222324252627282930313233343536373839package cn.hy.study.basictype;import java.io.PrintStream;public class PrimitiveTypeStudy&#123; public static void main(String[] args) &#123; Long wrapperLong = Long.valueOf(1L); long aLong = wrapperLong.longValue(); add(Long.valueOf(1L), Long.valueOf(1L)); add(Long.valueOf(1L), 1L); add(1L, 1L); &#125; public static Long add(Long first, Long second) &#123; if (first.equals(second)) &#123; return Long.valueOf(first.longValue() + second.longValue()); &#125; return first; &#125; public static long add(Long first, long second) &#123; if (first.equals(Long.valueOf(second))) &#123; return first.longValue() + second; &#125; return first.longValue(); &#125; public static long add(long first, long second) &#123; if (first == second) &#123; return first + second; &#125; return first; &#125;&#125; 通过javap -v -p PrimitiveTypeStudy.class 命令生成，字节码内容，为了对比的效果，我在前后加入反编译后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277Classfile /Users/jaryoung/project/demo/javabasic/out/production/classes/cn/hy/study/basictype/PrimitiveTypeStudy.class Last modified Apr 3, 2019; size 1530 bytes MD5 checksum db6d2b4373555e4e52196d58a3ba87b5 Compiled from "PrimitiveTypeStudy.java"public class cn.hy.study.basictype.PrimitiveTypeStudy minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #19.#44 // java/lang/Object."&lt;init&gt;":()V #2 = Class #45 // java/lang/Long #3 = Methodref #2.#46 // java/lang/Long."&lt;init&gt;":(J)V #4 = Methodref #2.#47 // java/lang/Long.longValue:()J #5 = Fieldref #48.#49 // java/lang/System.out:Ljava/io/PrintStream; #6 = Class #50 // java/lang/StringBuilder #7 = Methodref #6.#44 // java/lang/StringBuilder."&lt;init&gt;":()V #8 = String #51 // #9 = Methodref #6.#52 // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #10 = Methodref #6.#53 // java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; #11 = Methodref #6.#54 // java/lang/StringBuilder.toString:()Ljava/lang/String; #12 = Methodref #55.#56 // java/io/PrintStream.println:(Ljava/lang/String;)V #13 = Methodref #2.#57 // java/lang/Long.valueOf:(J)Ljava/lang/Long; #14 = Methodref #18.#58 // cn/hy/study/basictype/PrimitiveTypeStudy.add:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; #15 = Methodref #18.#59 // cn/hy/study/basictype/PrimitiveTypeStudy.add:(Ljava/lang/Long;J)J #16 = Methodref #18.#60 // cn/hy/study/basictype/PrimitiveTypeStudy.add:(JJ)J #17 = Methodref #2.#61 // java/lang/Long.equals:(Ljava/lang/Object;)Z #18 = Class #62 // cn/hy/study/basictype/PrimitiveTypeStudy #19 = Class #63 // java/lang/Object #20 = Utf8 &lt;init&gt; #21 = Utf8 ()V #22 = Utf8 Code #23 = Utf8 LineNumberTable #24 = Utf8 LocalVariableTable #25 = Utf8 this #26 = Utf8 Lcn/hy/study/basictype/PrimitiveTypeStudy; #27 = Utf8 main #28 = Utf8 ([Ljava/lang/String;)V #29 = Utf8 args #30 = Utf8 [Ljava/lang/String; #31 = Utf8 wrapperLong #32 = Utf8 Ljava/lang/Long; #33 = Utf8 aLong #34 = Utf8 J #35 = Utf8 add #36 = Utf8 (Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; #37 = Utf8 first #38 = Utf8 second #39 = Utf8 StackMapTable #40 = Utf8 (Ljava/lang/Long;J)J #41 = Utf8 (JJ)J #42 = Utf8 SourceFile #43 = Utf8 PrimitiveTypeStudy.java #44 = NameAndType #20:#21 // "&lt;init&gt;":()V #45 = Utf8 java/lang/Long #46 = NameAndType #20:#64 // "&lt;init&gt;":(J)V #47 = NameAndType #65:#66 // longValue:()J #48 = Class #67 // java/lang/System #49 = NameAndType #68:#69 // out:Ljava/io/PrintStream; #50 = Utf8 java/lang/StringBuilder #51 = Utf8 #52 = NameAndType #70:#71 // append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #53 = NameAndType #70:#72 // append:(J)Ljava/lang/StringBuilder; #54 = NameAndType #73:#74 // toString:()Ljava/lang/String; #55 = Class #75 // java/io/PrintStream #56 = NameAndType #76:#77 // println:(Ljava/lang/String;)V #57 = NameAndType #78:#79 // valueOf:(J)Ljava/lang/Long; #58 = NameAndType #35:#36 // add:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; #59 = NameAndType #35:#40 // add:(Ljava/lang/Long;J)J #60 = NameAndType #35:#41 // add:(JJ)J #61 = NameAndType #80:#81 // equals:(Ljava/lang/Object;)Z #62 = Utf8 cn/hy/study/basictype/PrimitiveTypeStudy #63 = Utf8 java/lang/Object #64 = Utf8 (J)V #65 = Utf8 longValue #66 = Utf8 ()J #67 = Utf8 java/lang/System #68 = Utf8 out #69 = Utf8 Ljava/io/PrintStream; #70 = Utf8 append #71 = Utf8 (Ljava/lang/String;)Ljava/lang/StringBuilder; #72 = Utf8 (J)Ljava/lang/StringBuilder; #73 = Utf8 toString #74 = Utf8 ()Ljava/lang/String; #75 = Utf8 java/io/PrintStream #76 = Utf8 println #77 = Utf8 (Ljava/lang/String;)V #78 = Utf8 valueOf #79 = Utf8 (J)Ljava/lang/Long; #80 = Utf8 equals #81 = Utf8 (Ljava/lang/Object;)Z&#123; public cn.hy.study.basictype.PrimitiveTypeStudy(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 14: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcn/hy/study/basictype/PrimitiveTypeStudy; /* public static void main(String[] args) &#123; Long wrapperLong = Long.valueOf(1L); long aLong = wrapperLong.longValue(); add(Long.valueOf(1L), Long.valueOf(1L)); add(Long.valueOf(1L), 1L); add(1L, 1L); &#125; */ public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=4, args_size=1 0: new #2 // class java/lang/Long 3: dup 4: lconst_1 5: invokespecial #3 // Method java/lang/Long."&lt;init&gt;":(J)V 8: astore_1 9: aload_1 10: invokevirtual #4 // Method java/lang/Long.longValue:()J 13: lstore_2 14: getstatic #5 // Field java/lang/System.out:Ljava/io/PrintStream; 17: new #6 // class java/lang/StringBuilder 20: dup 21: invokespecial #7 // Method java/lang/StringBuilder."&lt;init&gt;":()V 24: ldc #8 // String 26: invokevirtual #9 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 29: lload_2 30: invokevirtual #10 // Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; 33: invokevirtual #11 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 36: invokevirtual #12 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: lconst_1 40: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 43: lconst_1 44: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 47: invokestatic #14 // Method add:(Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; 50: pop 51: lconst_1 52: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 55: lconst_1 56: invokestatic #15 // Method add:(Ljava/lang/Long;J)J 59: pop2 60: lconst_1 61: lconst_1 62: invokestatic #16 // Method add:(JJ)J 65: pop2 66: return LineNumberTable: line 19: 0 line 21: 9 line 22: 14 line 23: 39 line 24: 51 line 25: 60 line 29: 66 LocalVariableTable: Start Length Slot Name Signature 0 67 0 args [Ljava/lang/String; 9 58 1 wrapperLong Ljava/lang/Long; 14 53 2 aLong J /* public static Long add(Long first, Long second) &#123; if (first.equals(second)) &#123; return Long.valueOf(first.longValue() + second.longValue()); &#125; return first; &#125; */ public static java.lang.Long add(java.lang.Long, java.lang.Long); descriptor: (Ljava/lang/Long;Ljava/lang/Long;)Ljava/lang/Long; flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=2, args_size=2 0: aload_0 1: aload_1 2: invokevirtual #17 // Method java/lang/Long.equals:(Ljava/lang/Object;)Z 5: ifeq 21 8: aload_0 9: invokevirtual #4 // Method java/lang/Long.longValue:()J 12: aload_1 13: invokevirtual #4 // Method java/lang/Long.longValue:()J 16: ladd 17: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 20: areturn 21: aload_0 22: areturn LineNumberTable: line 39: 0 line 40: 8 line 42: 21 LocalVariableTable: Start Length Slot Name Signature 0 23 0 first Ljava/lang/Long; 0 23 1 second Ljava/lang/Long; StackMapTable: number_of_entries = 1 frame_type = 21 /* same */ /* public static long add(Long first, long second) &#123; if (first.equals(Long.valueOf(second))) &#123; return first.longValue() + second; &#125; return first.longValue(); &#125; */ public static long add(java.lang.Long, long); descriptor: (Ljava/lang/Long;J)J flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=3, args_size=2 0: aload_0 1: lload_1 2: invokestatic #13 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long; 5: invokevirtual #17 // Method java/lang/Long.equals:(Ljava/lang/Object;)Z 8: ifeq 18 11: aload_0 12: invokevirtual #4 // Method java/lang/Long.longValue:()J 15: lload_1 16: ladd 17: lreturn 18: aload_0 19: invokevirtual #4 // Method java/lang/Long.longValue:()J 22: lreturn LineNumberTable: line 53: 0 line 54: 11 line 56: 18 LocalVariableTable: Start Length Slot Name Signature 0 23 0 first Ljava/lang/Long; 0 23 1 second J StackMapTable: number_of_entries = 1 frame_type = 18 /* same */ /* public static long add(long first, long second) &#123; if (first == second) &#123; return first + second; &#125; return first; &#125; */ public static long add(long, long); descriptor: (JJ)J flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=4, args_size=2 0: lload_0 1: lload_2 2: lcmp 3: ifne 10 6: lload_0 7: lload_2 8: ladd 9: lreturn 10: lload_0 11: lreturn LineNumberTable: line 68: 0 line 69: 6 line 71: 10 LocalVariableTable: Start Length Slot Name Signature 0 12 0 first J 0 12 2 second J StackMapTable: number_of_entries = 1 frame_type = 10 /* same */&#125;SourceFile: "PrimitiveTypeStudy.java" 结论除了 POJO 类属性 和 RPC 方法的返回值和参数之外，其他情况建议使用基本类型。 部分内容都是引用自： 《码出高效》https://www.baeldung.com/java-wrapper-classes]]></content>
      <tags>
        <tag>Java,Java基础,Java数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Docker（针对开发人员）]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%88%9D%E8%AF%86Docker%2F</url>
    <content type="text"><![CDATA[概括Docker 是世界领先的软件容器平台。开发人员利用 Docker 可以解决，“在我的机器上可正常工作的啊！！！”的问题 容器又是什么东西？容器是一种标准化的软件单元。容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。 图片出自：https://www.docker-cn.com/what-container 容器和虚拟机 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。 容器和虚拟机对比 容器 虚拟机 容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。 虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因 图片出自：https://www.docker-cn.com/what-container 图片出自：https://www.docker-cn.com/what-container 容器和虚拟机共用 将容器和虚拟机配合使用，为应用的部署和管理提供极大的灵活性。 图片出自：https://www.docker-cn.com/what-container 获取docker（针对Mac 用户） 建议注册一个账户 然后通过官网链接下载桌面版的Docker，官网超链接，如果想快一点可以试试看这个链接 。(默认最新稳定版) 下载完，安装好，配置一下Docker 中国官方镜像加速源 http://registry.docker-cn.com，当然你也是可以选择其他的加速源例如阿里，网易等等。配置完，记得点击Apply&amp;Restart。 打开Terminal ，输入一下命令 docker info 安装工具，到此结束了，是不是想说So easy？其实就是如此轻松，马上可以享受到Docker带来的快感吧！ 使用Docker我习惯上来先查一下，help（不想看，直接跳过哈，下面会开始讲，我目前经常使用的一些命令。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576docker helpUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default "/Users/jaryoung/.docker") -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default "/Users/jaryoung/.docker/ca.pem") --tlscert string Path to TLS certificate file (default "/Users/jaryoung/.docker/cert.pem") --tlskey string Path to TLS key file (default "/Users/jaryoung/.docker/key.pem") --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: builder Manage builds config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumesCommands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codesRun 'docker COMMAND --help' for more information on a command. docker search1234567891011docker search --helpUsage: docker search [OPTIONS] TERMSearch the Docker Hub for images，为了在Docker Hub上面搜 **资源**（你们都懂得）Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output 例如，我需要搜索一下上面有哪些mysql镜像，我们可以看到下面到信息： 123456docker search mysqlNAME（名称） DESCRIPTION（描述） STARS（多少次好评） OFFICIAL（官方） AUTOMATED（自动化）mysql MySQL is a widely used, open-source relation… 7964 [OK]mariadb MariaDB is a community-developed fork of MyS… 2665 [OK]mysql/mysql-server Optimized MySQL Server Docker images. Create… 598 [OK]... docker pull123456789docker pull --helpUsage: docker pull [OPTIONS] NAME[:TAG|@DIGEST]Pull an image or a repository from a registryOptions: -a, --all-tags Download all tagged images in the repository --disable-content-trust Skip image verification (default true) 例如，我们可以通过 docker pull mysql , 来下载最新版的mysql镜像。如果需要带上TAG，例如 docker pull mysql:5.7 docker run123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354docker run --helpUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]Run a command in a new containerOptions(删除了一部分，详细的情况，可以自己查询): --add-host list Add a custom host-to-IP mapping (host:ip) -d, --detach Run container in background and print container ID --detach-keys string Override the key sequence for detaching a container --device list Add a host device to the container --device-cgroup-rule list Add a rule to the cgroup allowed devices list --device-read-bps list Limit read rate (bytes per second) from a device (default []) --device-read-iops list Limit read rate (IO per second) from a device (default []) --device-write-bps list Limit write rate (bytes per second) to a device (default []) --device-write-iops list Limit write rate (IO per second) to a device (default []) --disable-content-trust Skip image verification (default true) --dns list Set custom DNS servers --dns-option list Set DNS options --dns-search list Set custom DNS search domains --entrypoint string Overwrite the default ENTRYPOINT of the image -e, --env list Set environment variables --env-file list Read in a file of environment variables --expose list Expose a port or a range of ports --group-add list Add additional groups to join --health-cmd string Command to run to check health --health-interval duration Time between running the check (ms|s|m|h) (default 0s) --health-retries int Consecutive failures needed to report unhealthy --health-start-period duration Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s) --health-timeout duration Maximum time to allow one check to run (ms|s|m|h) (default 0s) --help Print usage -h, --hostname string Container host name --init Run an init inside the container that forwards signals and reaps processes -p, --publish list Publish a container's port(s) to the host -P, --publish-all Publish all exposed ports to random ports --read-only Mount the container's root filesystem as read only --restart string Restart policy to apply when a container exits (default "no") --rm Automatically remove the container when it exits --runtime string Runtime to use for this container --security-opt list Security Options --shm-size bytes Size of /dev/shm --sig-proxy Proxy received signals to the process (default true) --stop-signal string Signal to stop a container (default "SIGTERM") --stop-timeout int Timeout (in seconds) to stop a container --storage-opt list Storage driver options for the container --sysctl map Sysctl options (default map[]) --tmpfs list Mount a tmpfs directory -t, --tty Allocate a pseudo-TTY --ulimit ulimit Ulimit options (default []) ... -v, --volume list Bind mount a volume --volume-driver string Optional volume driver for the container --volumes-from list Mount volumes from the specified container(s) -w, --workdir string Working directory inside the container Mysql1docker run -p 3306:3306 --name mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6.43 -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。 -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。 -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。 -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。 -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。 Redis1docker run -p 6379:6379 -v $PWD/data:/data --name redis -d redis redis-server --appendonly yes 命令说明： -p 6379:6379 : 将容器的6379端口映射到主机的6379端口 -v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data redis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 Nginx首先，我需要创建一下，文件夹,用于主宿机之间做映射使用。 1mkdir -p &#123;conf.d,html,logs&#125; 1docker run -p 80:80 -p 84:84 -p 82:82 --name nginx -v $PWD/www:/www -v $PWD/html:/usr/share/nginx/html -v $PWD/logs:/wwwlogs -v $PWD/conf.d:/etc/nginx/conf.d -d nginx 命令说明： -p 80:80：主机80到容器80，-p 84:84，同理（主机 -&gt; 宿机） –name mynginx：将容器命名为nginx -v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www -v $PWD/conf/conf.d:/etc/nginx/conf.d：将主机中当前目录下的conf.d挂载到容器的/etc/nginx/conf.d 不能挂载文件，只能挂载文件夹 注意如果提醒你，是否不应该将一个文件夹挂载到文件下面，我需要自己手动创建一个nginx.conf配置文件，并放置到主机的映射配置文件夹中（$PWD/conf），重新执行即可。如果出现了没有访问你配置的静态资源，很可能是访问到默认的配置（conf.d/default.conf）,可以选择删除它，也可以选择覆盖/etc/nginx/nginx.conf，但是前提需要备份原来的nginx.conf或者在原nginx.conf上做修改会更加适合。 -v $PWD/html:/usr/share/nginx/html，讲主机中当前的目录下的文件夹挂载到容器中 这里映射不正确，很有可能导致访问403 拒绝访问的情况，如果你的html不是资源访问的跟路径，请配置正确的根路径，例如，资源是放在html/hello的文件中，需要配置到$PWD/html/hello，而不是$PWD/html。 -v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs docker ps123456789101112131415docker ps --helpUsage: docker ps [OPTIONS]List containersOptions: -a, --all Show all containers (default shows just running) -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template -n, --last int Show n last created containers (includes all states) (default -1) -l, --latest Show the latest created container (includes all states) --no-trunc Don't truncate output -q, --quiet Only display numeric IDs -s, --size Display total file sizes 例如，我们可以运行 docker ps -a ,查询一下我们容器中启动的镜像的情况： 1234CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4b9f565ae5ad nginx "nginx -g 'daemon of…" 8 hours ago Up 4 minutes 0.0.0.0:84-&gt;80/tcp nginx46519e512d58 redis "docker-entrypoint.s…" 10 hours ago Up 5 minutes 0.0.0.0:6379-&gt;6379/tcp redis293c9831f58a mysql:5.6.43 "docker-entrypoint.s…" 10 hours ago Up 4 minutes 0.0.0.0:3306-&gt;3306/tcp mysql 命令说明： -a Show all containers (default shows just running)，会显示所有存在的，默认是之后显示当前容器启动的镜像。 docker stop12345678docker stop --helpUsage: docker stop [OPTIONS] CONTAINER [CONTAINER...]Stop one or more running containersOptions: -t, --time int Seconds to wait for stop before killing it (default 10) docker start12345678910docker start --helpUsage: docker start [OPTIONS] CONTAINER [CONTAINER...]Start one or more stopped containers，可以启动一个或者多个容器Options: -a, --attach Attach STDOUT/STDERR and forward signals --detach-keys string Override the key sequence for detaching a container -i, --interactive Attach container's STDIN 例如，我们可以通过 docker start nginx mysql ，同时启动两个容器 docker exec123456789101112131415docker exec --helpUsage: docker exec [OPTIONS] CONTAINER COMMAND [ARG...]Run a command in a running containerOptions: -d, --detach Detached mode: run command in the background --detach-keys string Override the key sequence for detaching a container -e, --env list Set environment variables -i, --interactive Keep STDIN open even if not attached --privileged Give extended privileges to the command -t, --tty Allocate a pseudo-TTY -u, --user string Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) -w, --workdir string Working directory inside the container 例如，我们可以通过命令快速进入到redis-cli，docker exec -it redis redis-cli，输入exit 就可以推出 很多内容都是引用自： http://www.runoob.com/docker/docker-tutorial.htmlhttps://www.docker-cn.com]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
